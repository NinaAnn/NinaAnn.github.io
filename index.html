<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="English">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Nina&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Nina&#39;s Blog">
<meta property="og:locale" content="English">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nina&#39;s Blog">






  <link rel="canonical" href="http://yoursite.com/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Nina's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="English">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Nina's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Good Good Study, Day Day Up</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/01/10/kafka学习笔记一：整体了解kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/01/10/kafka学习笔记一：整体了解kafka/" itemprop="url">
                  kafka学习笔记一：整体了解kafka
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2024-01-10 21:43:07 / Modified: 23:18:01" itemprop="dateCreated datePublished" datetime="2024-01-10T21:43:07+08:00">2024-01-10</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/kafka/" itemprop="url" rel="index"><span itemprop="name">kafka</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h1><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>因为mq很常见嘛所以就不多介绍啦，看一下消息队列的两种模式</p>
<h3 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h3><p>消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费后，queue中不再有存储，所以消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对于一个消息而言，只有一个消费者可以消费。（其实kafka的每个consumer group内可以理解为是点对点模式）</p>
<h3 id="消息-订阅模式"><a href="#消息-订阅模式" class="headerlink" title="消息/订阅模式"></a>消息/订阅模式</h3><p>消息生产者（发布）将消息发布到topic中，同时有多个消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。也就是kafka使用的模式</p>
<h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img src="/../images/distribution/kafka基础.png" alt="image-20221008131302682"></p>
<p>这张图感觉看过好多好多遍。。。</p>
<ul>
<li>Producer：消息生产者（发布）将消息发布到topic中，同时有多个消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。</li>
<li>Consumer：消息消费者，向kafka broker取消息的客户端</li>
<li>Consumer Group：消费者组，由多个consumer组成。消费者组每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。所有的消费者属于某个消费者组，即消费者组是逻辑上的一个订阅者</li>
<li>Broker：一台Kafka服务器就是一个broker。一个集群由多个broker组成，一个broker可以容纳多个topic</li>
<li>Topic：可以理解为一个队列，生产者和消费者面向的都是一个topic</li>
<li>Partition：为了实现扩展性，一个非常大的topic分为多个partition，partition可以理解为物理分区，是最小的<strong>存储单元</strong>，掌握着一个 Topic 的部分数据。</li>
<li>Replication：副本，为保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 仍然能够继续工作，kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower</li>
</ul>
<h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>作为kafka的存储核心，还是单独捞出来写一下吧</p>
<p>Partition 中的每条记录都会被分配一个唯一的序号，称为 <strong>Offset</strong>（偏移量），Offset 是一个递增的、不可变的数字，由 Kafka 自动维护，当一条记录写入 Partition 的时候，它就被追加到 log 文件的末尾，并被分配一个序号，作为 Offset。</p>
<p>消息的顺序性：一个 Topic 如果有多个 Partition 的话，那么从 Topic 这个层面来看，消息是无序的。但单独看 Partition 的话，Partition 内部消息是有序的。所以，一个 Partition 内部消息有序，一个 Topic 跨 Partition 是无序的。如果强制要求 Topic 整体有序，就只能让 Topic 只有一个 Partition。</p>
<p>一个 Kafka 集群由多个 Broker（就是 Server） 构成，每个 Broker 中含有集群的部分数据，Kafka 把 Topic 的多个 Partition 分布在多个 Broker 中。</p>
<p>好处：</p>
<ul>
<li>增加吞吐量，把partition放在不同的broker里，那么整个topic的吞吐就不会受限于一台机器的i/o性能</li>
<li>增加consumer消费能力，把不同的consumer分配去消费不同的partition，Consumer 的多个实例就可以连接不同的 Broker，大大提升了消息处理能力。</li>
<li>增加数据备份，一个partition在不同的broker分为leader和follower去备份数据</li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>看一下kafka的存储机制：</p>
<p><img src="/../images/distribution/kafka文件存储.png" alt="image-20221008142532471"></p>
<p>其实就是分片和索引的机制，每个index文件里面都会以当前segment的第一条消息的offset命名，并且顺序向下记录，本质上就是实现了一套稀疏索引。</p>
<p>要查找一个offset的数据的时候，先去遍历每个segment，定位到该offset在哪个segment里面，再在segment里面查找到对应offset的数据</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者负责的是发送消息到对应的partition，所以需要确认的有以下件事</p>
<p>一：发送数据到哪个partition </p>
<p>二：partition对应的broker是哪个</p>
<p>三：如何保证数据已经发送成功，需不需要重试</p>
<h4 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h4><p>其实分区器前面还有拦截器和序列化器，分别做了一些数据处理和数据序列化的逻辑，之后分区器用来确定需要发送的分区，kafka提供了三种分区方式：</p>
<ol>
<li>指定partition的情况下，直接将指定的值作为partition值</li>
<li>没有指定partition值但有key的情况下，将key的hash 值与 topic 的 partition 数进行取余得到 partition 值</li>
<li>既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 round-robin 算法。</li>
</ol>
<h4 id="broker信息"><a href="#broker信息" class="headerlink" title="broker信息"></a>broker信息</h4><p>这个后面会提到，kafka的集群是借助zk管理的，也就是说每个brocker都会向zk注册。而kafka集群中会选举一个broker作为controller，controller会负责整个集群的主题管理（包括主题创建，删除，分区分配，增加和重分配）等操作。</p>
<p>Kafka使用了一种称为”Metadata Request”的机制来获取Broker的元数据信息。当Producer需要发送消息到指定Partition时，它会向Kafka集群发送一个Metadata Request请求，请求包含了目标Topic和Partition的信息。</p>
<p>Kafka集群中的一个Broker（通常是Controller）会接收到这个请求，并返回包含了目标Partition所在的Broker的元数据信息的响应。这个元数据信息包括了Broker的地址（IP和端口），Producer可以根据这些信息来建立与目标Broker的连接。</p>
<p>producer本地有一个属性会保存集群中broker的列表，但是Kafka的元数据信息是动态变化的，因为集群中的Broker和Partition可能会发生变化。因此，Producer通常会定期或在需要时发送Metadata Request来获取最新的元数据信息，以确保消息发送到正确的Broker和Partition。</p>
<h4 id="数据可靠性"><a href="#数据可靠性" class="headerlink" title="数据可靠性"></a>数据可靠性</h4><p>为保证producer发送的数据，即可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement 确认收到），如果producer收到ack，就会进行下一轮发送，否则会重新发送数据。</p>
<p>那么什么时候发送ack呢？</p>
<p>首先producer发送的一定是leader节点，leader节点收到数据之后会有两个操作，一个是落盘，一个是同步数据到follower，所以这里kafka提供了三种不同的ack返回方案配置：</p>
<ul>
<li>0：producer不等待broker的ack，这一操作提供了一个最低的延迟，broker一接受到还没有写入磁盘就已经返回，当broker由故障的时候有可能丢失数据</li>
<li>1：producer等待broker的ack，partition的leader落盘成功后返回ack，如果follower同步成功之前leader故障，那么将丢失数据</li>
<li>-1（all）：producer等待broker的ack，partition的leader和follower全部落盘成功后才返回ack。但是如果follower同步成功之后，broker发送ack之前，leader发生故障，那么会操成数据重复</li>
</ul>
<p>0和-1，一个是at most once，最多只发一次，数据不重复，但是会丢失，一个是at least once，数据保证不会丢失但是会重复，所以用容易丢失的方案则要考虑数据是否重要，用at least once的方案就需要考虑数据幂等性</p>
<p>至于all的方案，zk我们知道，是只要保证有一半以上的follower同步成功就ok，但是kafka选择的则是全部follower都同步成功才可以，因为如果用zk的方案，2n+1，那么就会有n台机器是增加出来的应付故障的冗余数据，zk的znode节点数据相当小，但是kafka这种侧重数据存储的逻辑会造成n台机器的数据冗余，成本过高</p>
<p><strong>ISR</strong></p>
<p>那么如果其中有一台机器出问题了同步不了怎么办？ack就一直卡在那里么？</p>
<p>Leader 维护了一个动态的 in-sync replica set (ISR)，意为和 leader 保持同步的 follower 集合。当 ISR 中的 follower 完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower长时间未向leader 同步数据 ， 则该 follower将 被 踢 出 ISR，该时间阈值由<code>replica.lag.time.max.ms</code> 参数设定。Leader 发生故障之后，就会从 ISR 中选举新的 leader。</p>
<p><strong>数据幂等</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; Kafka 通过 Producer Id（生产者标识符）和 Sequence Number（序列号）来保证消息不会被重复发送。以下是 Kafka 如何实现这一点的工作原理：</span><br><span class="line">&gt; </span><br><span class="line">&gt; Producer Id（PID）： 每个 Kafka 生产者在初始化时都会获得一个唯一的 Producer Id。Producer Id 是一个持久性标识符，通常与生产者的客户端实例相关联。Kafka 会跟踪每个生产者的 Producer Id。</span><br><span class="line">&gt; </span><br><span class="line">&gt; Sequence Number（序列号）： 每个请求（消息）都包含一个单调递增的序列号。序列号从1开始，每次递增1。序列号用于标识请求的顺序。</span><br><span class="line">&gt; </span><br><span class="line">&gt; Producer Id 和 Sequence Number 的存储： Kafka 将 Producer Id 和 Sequence Number 存储在每个分区的分区日志中。这个存储允许 Kafka 跟踪每个分区的最新序列号。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 消息发送过程： 当生产者发送一条消息到 Kafka 时，消息会携带生产者的 Producer Id 和序列号。Kafka 会根据 Producer Id 和序列号来验证消息的幂等性和顺序性。</span><br><span class="line">&gt; </span><br><span class="line">&gt; Kafka 服务器的处理： Kafka 服务器会在接收到消息后，首先检查 Producer Id 和序列号是否已经在该分区的分区日志中出现过。如果这个 Producer Id 和序列号已经存在，说明消息已经被处理，Kafka 将丢弃重复的消息。如果 Producer Id 和序列号是新的，Kafka 会接受消息并更新分区的最新序列号。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 重试机制： 如果生产者因某种原因未收到来自 Kafka 的确认（ACK）并怀疑消息未被成功发送，它会重新发送相同的消息。由于消息中包含了 Producer Id 和序列号，Kafka 可以识别重复的消息并再次将其过滤掉。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 通过这个机制，Kafka 确保了消息不会被重复发送。每条消息都有唯一的 Producer Id 和序列号，这使得 Kafka 能够在接收消息时检查重复，并且保持消息的幂等性和顺序性。这对于确保数据的可靠性和一致性非常重要，尤其在分布式系统中。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><h4 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h4><p>pull模式：消费者从broker中主动拉取数据</p>
<p>好处：</p>
<ol>
<li>消费者可以根据自己的消费速率来控制拉取速度</li>
<li>消费者可以自由决定拉取的数据量，比如我们之前一批一百个拉数据处理，可以避免高频少量数据写入ck</li>
<li>可以通过增加消费者的数量来增加吞吐量（我理解要结合partition数量来看）</li>
</ol>
<p>上面讲到Kafka采用pull模式获取数据, 在没有数据时会进行空转, Kafka针对这一点采用在消费者消费数据时传入一个时长参数 timeout, 如果没消息是, 消费者等待该 time</p>
<h3 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h3><p>我们已知一个consumer group内采用的是点对点的策略，也就是说每个consumer消费的内容是不一样的，kafka采用的是把partition分配给consumer的逻辑，那么把哪个分区分配到哪个consumer呢？</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>对于每个topic，Range是对每个Topic而言的（即一个Topic一个Topic的分），首先对同一个Topic里面的分区按照序号进行排序，并对消费者按字母顺序进行排序，然后用partitions分区的个数除以消费者线程的总数来决定每个消费者线程消费几个分区，如果除不尽，那么前几个消费者线程将会多消费一个分区。</p>
<p>这样对于单个topic来说，分配是尽可能平衡的，但是如果这个consumer消费了多个topic呢？</p>
<p>假如我们有两个topic T1,T2，分别有10个分区，最后的分配结果将会是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C1-0：T1（0，1，2，3） T2（0，1，2，3）</span><br><span class="line">C2-0：T1（4，5，6） T2（4，5，6）</span><br><span class="line">C2-1：T1（7，8，9） T2（7，8，9）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如上，只针对一个topic而言，C1-0消费者多消费1个分区影响不是很大。如果有 N 多个 topic，那么针对每个 topic，消费者 C1-0 都将多消费 1 个分区，topic越多，C1-0 消费的分区会比其他消费者明显多消费 N 个分区。这就是 Range 范围分区的一个很明显的弊端了</p>
</blockquote>
<h4 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a>RoundRobin</h4><p>总觉得很耳熟不知道为啥</p>
<p>RoundRobinAssignor策略的原理是将消费者组内所有消费者以及消费者所订阅的所有topic的partition按照字典序排序，然后通过轮询的方式逐个将分区以此分配给每个消费者。</p>
<p>使用RoundRobinAssignor策略有两个前提条件必须满足：</p>
<ol>
<li>同一个消费者组里面的所有消费者的num.streams（消费者线程数）必须相等</li>
<li>每个消费者订阅的主题必须相同<ol>
<li>如果消费者订阅的主题不一样的话，如果某个消费者没有订阅某个topic，那么分配的时候会跳过这个消费者，会导致分配的不均匀</li>
</ol>
</li>
</ol>
<h4 id="StickyAssignor"><a href="#StickyAssignor" class="headerlink" title="StickyAssignor"></a>StickyAssignor</h4><p>代码逻辑本身很复杂，没仔细看，比起前面的分配原则可以看一下区别</p>
<p>sticky这个词的意思是黏性的，其实也就是说重分配的时候，尽量把原来就在这个consumer下的分区保留，这样可以减少销毁和重新建立连接的开销</p>
<h3 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h3><h4 id="消费者offset"><a href="#消费者offset" class="headerlink" title="消费者offset"></a>消费者offset</h4><p>每个消费者在消费每个分区的时候都会记录自己当前消费的offset，那么如果consumer出现故障，或者是服务重新发布之后，需要从之前的offset开始消费，所以这个offset不能被consumer自己保存，自己保存的话服务重建就不见了</p>
<p>kafka本身保存了消费者offset，可以想象成一个kv</p>
<p>key是由consumer group id + topic + partition 共同构成的复合key，value是offset</p>
<p>这个offset在kafka 0.9版本的时候是保存在zk的，但是zk这玩意儿频繁写不是什么好事，所以新版把这个值写入了kafka的一个内部topic，即<code>__consumer_offsets</code> topic，并且默认提供了<code>kafka_consumer_groups.sh</code>脚本供用户查看consumer信息。</p>
<h4 id="partition水位"><a href="#partition水位" class="headerlink" title="partition水位"></a>partition水位</h4><p>partition水位也就是partition当前的最大可读offset的值，这里引入两个概念HW（high watermark）和LEO（log end offset）</p>
<p>hw就是当前partition最大可读的offset</p>
<p><img src="/../images/distribution/hw和leo.png" alt="image-20221010155119686"></p>
<p>当follower挂了，follower发生故障后会被临时提出ISR，待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步，等该follower的LEO大于等于该Partition的HW，即follower追上leader之后，就可以重新加入ISR了。</p>
<p>如果是leader挂了呢？leader发生故障后，会从ISR种选出一个新的leader，之后，为保证多个副本之间数据一致性，其余的follower会先将各自log文件高于HW的部分截掉，然后从新的leader同步数据。</p>
<p>虽然我不大确定leader的选举机制，但是i guess是leo最大的</p>
<p>那么hw是怎么同步的？</p>
<ol>
<li><p>首先，生产者不停地向Leader写入数据，这时候Leader的LEO可能已经达到了10，但是HW依然是0，两个Follower向Leader请求同步数据，他们的值都是0。</p>
</li>
<li><p>然后，消息还在继续写入，Leader的LEO值又发生了变化，两个Follower也各自拉取到了自己的消息，于是更新自己的LEO值，但是这时候Leader的HW依然没有改变。</p>
</li>
<li>此时，Follower再次向Leader拉取数据，这时候Leader会更新自己的HW值，取Follower中的最小的LEO值来更新。</li>
<li>之后，Leader响应自己的HW给Follower，Follower更新自己的HW值，因为又拉取到了消息，所以再次更新LEO，流程以此类推。</li>
</ol>
<h2 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h2><h3 id="缓冲和缓存"><a href="#缓冲和缓存" class="headerlink" title="缓冲和缓存"></a>缓冲和缓存</h3><p>缓存区是内存和cpu之间的存储区，用来存储cpu多次从内存读取到的数据，多次读取同一变量，就会将该变量放到缓存区中，当再次调用时直接从缓存区取，不从内存中取，当内存中该变量改变时，这种情况会导致内存不可见问题；这样做的目地是比访问内存更快。具体可以自己看高速缓存</p>
<p>缓冲区是内存中的存储区， 缓冲区分为内核缓冲区和用户缓冲区；功能不同。</p>
<p>内核缓冲区是网络传输，文件io，控制台输入输入等操作的“中转站”，为不可见内存，即用户不能直接使用。</p>
<p>内核缓冲区是为了暂时存储磁盘数据，因为每次从磁盘读数据开销非常大，所以比方说文件读取，最大的性能瓶颈就卡在了读磁盘上</p>
<ol>
<li>数据预读<ol>
<li>数据预读指的是，当程序发起 read() 系统调用时，内核会比请求更多地读取磁盘上的数据，保存在缓冲区，以备程序后续使用。这种数据的预取策略其实就是基于局部性原理</li>
<li>因此当我们向内核请求读取数据时，内核会先到内核缓冲区中去寻找，如果命中数据，则不需要进行真正的磁盘 I/O，直接从缓冲区中返回数据就行了；如果缓存未命中，则内核会从磁盘中读取请求的 page，并同时读取紧随其后的几个 page（比如三个），如果文件是顺序访问的，那么下一个读取请求就会命中之前预读的缓存（当然了，预读算法非常复杂，这里只是一个简化的逻辑）。</li>
</ol>
</li>
<li>延时回写<ol>
<li>延时回写指的是，当程序发起 write() 系统调用时，内核并不会直接把数据写入到磁盘文件中，而仅仅是写入到缓冲区中，几秒后（或者说等数据堆积了一些后）才会真正将数据刷新到磁盘中。对于系统调用来说，数据写入缓冲区后，就返回了。</li>
<li>延迟往磁盘写入数据的最大一个好处就是，可以合并更多的数据一次性写入磁盘，把小块的 I/O 变成大块 I/O，减少磁盘处理命令次数，从而提高提盘性能。</li>
<li>另一个好处是，当其它进程紧接着访问该文件时，内核可以从直接从缓冲区中提供更新的文件数据（这里又是充当 Cache 了）。</li>
</ol>
</li>
</ol>
<p>用户缓冲区则是可见内存，对用户来说可以直接使用。</p>
<p>因为内核缓冲区是不可见的，所以如果用户需要读内核缓冲区的数据，则需要切换到内核态，把数据读出来再切换到用户态放进堆里，涉及到上下文切换和堆栈变化。所以后来就设计了用户缓冲区，和内核缓冲区的操作是一样一样的，就是作用不一样，一个是为了减少磁盘io，一个是为了减少上下文切换</p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>那么说完上面的先看一下正常来说查看一个磁盘文件的流程：</p>
<p>Step1: 从磁盘中读取数据到内核缓冲区</p>
<p>Step2: cpu从缓存中拷贝到用户缓冲区</p>
<p><img src="/../images/distribution/缓冲区.png" alt="image.png"></p>
<p>写同理，用户缓冲区-&gt;socket缓冲区-&gt;网卡</p>
<p>对于kafka来说整个IO的过程需要进行两次DMA拷贝，两次CPU拷贝，四次上下文切换。总共四次拷贝，四次切换。这个代价确实有些大。</p>
<p>那么零拷贝技术倒也不是说真的就不拷贝了，而是尽量根据不同场景简化文件读写的拷贝次数，从而尽量减少上下文切换，提高数据传输效率。</p>
<p>歪个楼，虽然不是kafka的零拷贝，但是也是一种零拷贝技术：mmap+write，本质上就是利用mmap将内核缓冲区的的地址直接映射到用户缓冲区，具体可以看一下这个博客：<a href="https://baijiahao.baidu.com/s?id=1769186849807925293&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1769186849807925293&amp;wfr=spider&amp;for=pc</a></p>
<p><img src="/../images/distribution/mmap零拷贝.png" alt="img"></p>
<p>而kafka用到的就是文中的sendfile()方法，基于<strong>java.nio</strong>包下的<strong>FileChannel.transferTo()</strong>实现零拷贝。简单解释就是不需要走一遍用户进程和用户缓冲区的处理，直接把数据copy到socket缓冲区</p>
<p><img src="/../images/distribution/sendfile零拷贝.png" alt="img"></p>
<p>这种方式下用户程序不能对数据进行修改，而只是单纯地完成了一次数据传输过程。整个拷贝过程会发生 2 次上下文切换，1 次 CPU 拷贝和 2 次 DMA 拷贝。</p>
<h3 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h3><p>Kafka 对消息的存储和缓存严重依赖于文件系统。人们对于“磁盘速度慢”具有普遍印象，事实上，磁盘的速度比人们预期的要慢的多，也快得多，这取决于人们使用磁盘的方式。</p>
<p>Kafka重度依赖底层OS提供的page cache功能。当上层有写操作时，OS只是将数据写入到page cache，同时标记page属性为dirty。当读操作发生时，先从page cache中查找，如果发生缺页才进行磁盘调度，最终返回需要的数据。</p>
<p>个人理解page cache就是上面提到的内核缓冲区</p>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p><img src="/../images/distribution/kafka_zk.png" alt="在这里插入图片描述"></p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>这就又要提到前面写过的controller了</p>
<p>怎么选出来的呢controller，就是和zk帮忙选master一样，所有broker都会去注册controller节点，最小的那个就是当前的controller</p>
<ol>
<li>主题管理：这里的主题管理，就是指控制器帮助我们完成对 Kafka 主题的创建、删除以及分区增加的操作。换句话说，当我们执行kafka-topics 脚本时，大部分的后台工作都是控制器来完成的。</li>
<li>分区重分配：主要是指，kafka-reassign-partitions 脚本提供的对已有主题分区进行细粒度的分配功能。这部分功能也是控制器实现的。</li>
<li>Preferred 领导者选举：主要是 Kafka 为了避免部分 Broker 负载过重而提供的一种换 Leader 的方案。后面会详细介绍</li>
<li>集群成员管理：这是控制器提供的第 4 类功能，包括自动检测新增 Broker、Broker 主动关闭及被动宕机。<ol>
<li>这种自动检测是依赖于zk的Watch 功能和 ZooKeeper 临时节点组合实现的。比如，控制器组件会利用Watch 机制检查 ZooKeeper 的 /brokers/ids 节点下的子节点数量变更。目前，当有新 Broker 启动后，它会在 /brokers 下创建专属的 znode 节点。一旦创建完毕，ZooKeeper 会通过 Watch 机制将消息通知推送给控制器，这样，控制器就能自动地感知到这个变化，进而开启后续的新增 Broker 作业。</li>
<li>侦测 Broker 存活性则是依赖于zk的另一个机制：临时节点。每个 Broker 启动后，会在 /brokers/ids 下创建一个临时 znode。当 Broker 宕机或主动关闭后，该 Broker 与 ZooKeeper 的会话结束，这个 znode 会被自动删除。同理，ZooKeeper 的 Watch 机制将这一变更推送给控制器，这样控制器就能知道有 Broker 关闭或宕机了，从而进行“善后”。</li>
</ol>
</li>
<li>控制器的最后一大类工作，就是向其他 Broker 提供数据服务。控制器上保存了最全的集群元数据信息，其他所有 Broker 会定期接收控制器发来的元数据更新请求，从而更新其内存中的缓存数据。</li>
</ol>
<h3 id="节点注册"><a href="#节点注册" class="headerlink" title="节点注册"></a>节点注册</h3><p>看上面的图就能看出来，broker注册在broker/ids节点下，topic注册在broker/topics下</p>
<p>消费者组注册在consumers/{group_id}节点下，下面有三个子节点分别是：</p>
<p>ids：消费者</p>
<p>owners：该消费者组消费的topic</p>
<p>offsets：记录每个topic每个partition的offset</p>
<p><img src="/../images/distribution/kafka_zk注册.png" alt="image-20221009184409066"></p>
<h3 id="分区重分配"><a href="#分区重分配" class="headerlink" title="分区重分配"></a>分区重分配</h3><p>当集群中增加或者broker宕机的时候，需要让分区副本再次进行合理的分配，也就是所谓的分区重分配。</p>
<ol>
<li>生成一个分区分配方案</li>
<li>先通过控制器为每个分区添加新副本(增加副本因子) ， 新的副本将从分区的 leader副本那里复制所有的数据。根据分区的大小不同， 复制过程可能需要花一些时间， 因为数据是通过网络复制到新副本上的。</li>
<li>在复制完成之后，控制器将旧副本从副本清单里移除(恢复为原先的副本因子数)。注意在重分配的过程中要确保有足够的空间。</li>
</ol>
<h3 id="Leader和Follower"><a href="#Leader和Follower" class="headerlink" title="Leader和Follower"></a>Leader和Follower</h3><p>先说一下replica的概念，就是对同一个分区，为了保证数据不丢失，会给数据搞多个副本用于存储和同步，也就是leader和follower，不过和zk不一样，kafka的follower只负责同步，所有的数据生产和消费都是走leader的</p>
<p>常见的有以下几种情况会触发Partition的Leader Replica选举：</p>
<ol>
<li><strong>Leader Replica 失效：</strong>当 Leader Replica 出现故障或者失去连接时，Kafka 会触发 Leader Replica 选举。</li>
<li><strong>Broker 宕机：</strong>当 Leader Replica 所在的 Broker 节点发生故障或者宕机时，Kafka 也会触发 Leader Replica 选举。</li>
<li><strong>新增 Broker：</strong>当集群中新增 Broker 节点时，Kafka 还会触发 Leader Replica 选举，以重新分配 Partition 的 Leader。</li>
<li><strong>新建分区：</strong>当一个新的分区被创建时，需要选举一个 Leader Replica。</li>
<li><strong>ISR 列表数量减少：</strong>当 Partition 的 ISR 列表数量减少时，可能会触发 Leader Replica 选举。当 ISR 列表中副本数量小于 <strong>Replication Factor（副本因子）</strong>时，为了保证数据的安全性，就会触发 Leader Replica 选举。</li>
<li><strong>手动触发：</strong>通过 Kafka 管理工具（kafka-preferred-replica-election.sh），可以手动触发选举，以平衡负载或实现集群维护</li>
</ol>
<p><strong>leader选举</strong></p>
<p>用zk的master原则，brokers注册顺序最小的就会变成leader</p>
<p><strong>leader负载均衡</strong></p>
<p>理论上我们肯定希望leader分布在不同的broker上，这样所有的broker都可以承担起一部分i/o，不会导致某个broker负载过高</p>
<p>Preferred Replica是Kafka中的一个概念，用于指定每个分区的首选副本（Preferred Replica）。首选副本是指在进行Leader选举时，优先选择作为分区Leader的副本。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/01/10/zookeeper学习笔记一：整体了解zk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/01/10/zookeeper学习笔记一：整体了解zk/" itemprop="url">
                  zookeeper学习笔记一：整体了解zk
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2024-01-10 15:48:34 / Modified: 23:13:26" itemprop="dateCreated datePublished" datetime="2024-01-10T15:48:34+08:00">2024-01-10</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/distribution/" itemprop="url" rel="index"><span itemprop="name">distribution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>写在一切开始的cap，所有分布式系统都需要关注的内容</p>
<p><strong>①</strong> <strong>C：Consistency</strong>，一致性，数据一致更新，所有数据变动都是同步的。</p>
<p><strong>②</strong> <strong>A：Availability</strong>，可用性，系统具有好的响应性能。</p>
<p><strong>③</strong> <strong>P：Partition tolerance</strong>，分区容错性。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用。</p>
<p>该理论已被<strong>证明</strong>：任何分布式系统只可同时满足两点，无法三者兼顾。 因此，将精力浪费在思考如何设计能满足三者的完美系统上是愚钝的，应该根据应用场景进行适当取舍。</p>
<h3 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h3><p><strong>① 强一致性</strong>（strong consistency）。任何时刻，任何用户都能读取到最近一次成功更新的数据。</p>
<p><strong>② 单调一致性</strong>（monotonic consistency）。任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说，可获取的数据顺序必是单调递增的。</p>
<p><strong>③ 会话一致性</strong>（session consistency）。任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在本次会话中就不会再读到比这个值更旧的值。会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障。</p>
<p><strong>④</strong> <strong>最终一致性</strong>（eventual consistency）。用户只能读到某次更新后的值，但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障。</p>
<p><strong>⑤ 弱一致性</strong>（weak consistency）。用户无法在确定时间内读到最新更新的值。</p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>zk其实算是一个分布式管理系统，管理分布式节点的配置维护，可用性协调等等等等。打个最熟悉的比方hdfs里面，如果master节点挂了往往要再选举出一个master来，那么这个master节点挂了是怎么感知的呢，正常理解肯定是定时ping，但是利用zk的话就可以注册节点并实时感知到master节点的状态，并且可以很方便地进行选举，从而减少了大量集群内部通信压力</p>
<p>实际上，hdfs，kafka，hBase等等底层的调度都用了zk</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><img src="/../images/distribution/zk目录结构.png" alt="img"></p>
<p>zk的目录结构和文件系统非常相似，有父节点，父节点下面可以创建子节点。</p>
<p>每个节点用路径来表示，路径必须是<strong>绝对</strong>且<strong>唯一</strong>的</p>
<h3 id="znode"><a href="#znode" class="headerlink" title="znode"></a>znode</h3><p>每个节点被称为一个znode，每个Znode由3部分组成:</p>
<p><strong>①</strong> stat：此为状态信息, 描述该Znode的版本, 权限等信息</p>
<p><strong>②</strong> data：与该Znode关联的数据</p>
<p><strong>③</strong> children：该Znode下的子节点</p>
<p>每个znode节点都有以下属性，后面会具体讲</p>
<p><img src="/../images/distribution/znode基本属性.png" alt="img"></p>
<p>znode有以下几个特征：</p>
<p> <strong>数据访问</strong></p>
<ol>
<li>ZooKeeper中的每个节点存储的数据要被<strong>原子性的操作</strong>。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。</li>
<li><p>ZooKeeper中的节点有两种，分别为<strong>临时节点</strong>和<strong>永久节点</strong>。节点的类型在创建时即被确定，并且不能改变。</p>
<ol>
<li>临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的临时节点不允许拥有子节点。</li>
<li>永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</li>
</ol>
</li>
<li><p>当创建Znode的时候，用户可以请求在ZooKeeper的路径结尾添加一个<strong>递增的计数</strong>。这个计数<strong>对于此节点的父节点来说</strong>是唯一的，它的格式为”%10d”(10位数字，没有数值的数位用0补充，例如”0000000001”)。当计数值大于232-1时，计数器将溢出。</p>
</li>
</ol>
<h2 id="功能和原理"><a href="#功能和原理" class="headerlink" title="功能和原理"></a>功能和原理</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>每个znode的基本操作有九个</p>
<p><img src="/../images/distribution/znode基本操作.png" alt="znode的基本操作"></p>
<h3 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h3><p>简单来说就是监听一个节点的变化，如果发生变化的话就会触发监听事件并且把消息传给监听的客户端，监听是一个一次性事件，结束之后需要重新设置watcher</p>
<h4 id="watch类型"><a href="#watch类型" class="headerlink" title="watch类型"></a>watch类型</h4><p>ZooKeeper所管理的watch可以分为两类：</p>
<p><strong>①</strong> 数据watch(data watches)：<strong>getData</strong>和<strong>exists</strong>负责设置数据watch<br><strong>②</strong> 孩子watch(child watches)：<strong>getChildren</strong>负责设置孩子watch</p>
<p>我们可以通过操作<strong>返回的数据</strong>来设置不同的watch：</p>
<p><strong>① getData和exists：</strong>返回关于节点的数据信息<br><strong>② getChildren：</strong>返回孩子列表</p>
<p>因此</p>
<p><strong>①</strong> 一个成功的<strong>setData操作</strong>将触发Znode的数据watch</p>
<p><strong>②</strong> 一个成功的<strong>create操作</strong>将触发Znode的数据watch以及孩子watch</p>
<p><strong>③</strong> 一个成功的<strong>delete操作</strong>将触发Znode的数据watch以及孩子watch</p>
<p><img src="/../images/distribution/watch触发.png" alt="img"></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WatchManager &#123;</span><br><span class="line">    // Logger</span><br><span class="line">    private static final Logger LOG = LoggerFactory.getLogger(WatchManager.class);</span><br><span class="line"></span><br><span class="line">    // watcher表</span><br><span class="line">    private final HashMap&lt;String, HashSet&lt;Watcher&gt;&gt; watchTable =</span><br><span class="line">        new HashMap&lt;String, HashSet&lt;Watcher&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    // watcher到节点路径的映射</span><br><span class="line">    private final HashMap&lt;Watcher, HashSet&lt;String&gt;&gt; watch2Paths =</span><br><span class="line">        new HashMap&lt;Watcher, HashSet&lt;String&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WatcherManager类用于管理watchers和相应的触发器。watchTable表示从节点路径到watcher集合的映射，而watch2Paths则表示从watcher到所有节点路径集合的映射</p>
<p>注册：客户端调用getData之后，服务器收到请求，就会将数据节点的路径以及 ServerCnxn(远程通信信息) 信息存储到 WatchManager 的 watchTable 和 watch2Paths 中。而同时客服端收到返回之后，也会在本地注册watcher到一个watchmanager</p>
<p>触发：客户端调用setData之后，服务器收到请求，修改完数据之后调用triggerWatch方法，服务器从之前的 watchManager 中获得 watchers，然后一个个调用 process 方法发送通知到客户端。客户端收到请求后转为watchedEvent进入waitingEvent队列，最终取出并执行processevent</p>
<h3 id="权限管理（ACL）"><a href="#权限管理（ACL）" class="headerlink" title="权限管理（ACL）"></a>权限管理（ACL）</h3><p>创建每个znode都会产生一个acl列表，列表中每个ACL 包括：</p>
<ol>
<li><p>权限perms</p>
<ol>
<li><strong>Create</strong> 允许对子节点Create 操作</li>
<li><strong>Read</strong> 允许对本节点GetChildren 和GetData 操作</li>
<li><strong>Write</strong> 允许对本节点SetData 操作</li>
<li><strong>Delete</strong> 允许对子节点Delete 操作</li>
<li><strong>Admin</strong> 允许对本节点setAcl 操作</li>
</ol>
</li>
<li><p>验证模式scheme</p>
<ol>
<li><strong>Digest</strong>：Client 端由用户名和密码验证，譬如user:pwd</li>
<li><strong>Digest</strong>： Client 端由主机名验证，譬如localhost</li>
<li><strong>Ip</strong>：Client 端由IP 地址验证，譬如172.2.0.0/24</li>
<li><strong>World</strong> ：固定用户为anyone，为所有Client 端开放权限</li>
</ol>
</li>
<li><p>具体内容expression：Ids</p>
</li>
</ol>
<p>Server 收到Client 发送的操作请求<strong>（</strong>除exists、getAcl 之外<strong>）</strong>，需要进行<strong>ACL 验证</strong>：对该请求携带的Author 明文信息加密，并与目标节点的ACL 信息进行比较，如果匹配则具有相应的权限，否则请求被Server 拒绝。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>一旦客户端与一台ZooKeeper服务器建立连接，这台服务器就会为该客户端创建一个新的会话。正常来说会话是长期的，保证客户端与zk服务器的正常连接，直到客户端主动断开连接，但是有两个意外情况：</p>
<ol>
<li><p>会话超时，每个会话仍旧有一个超时时间，如果服务器在超时时间段内没有收到任何请求，则相应的会话会过期。<strong>一旦一个会话已经过期，就无法重新打开，并且任何与该会话相关联的短暂znode都会丢失。</strong></p>
<p>解决方法：只要一个会话空闲超过一定时间，都可以通过客户端发送ping请求（也称为心跳）保持会话不过期。ping请求由ZooKeeper的客户端库自动发送，所以我们使用的时候不用考虑会话过期问题，同时ping也可以用来检测连接的服务器是否有问题</p>
</li>
<li><p>服务器故障：上面说到的，ping的时候可以监测服务故障（所以ping的时间间隔不应该太长）</p>
<p>ZooKeeper客户端可以自动地进行故障切换，切换至另一台ZooKeeper服务器。<strong>并且关键的一点是</strong>，在另一台服务器接替故障服务器之后，所有的会话和相关的短暂Znode仍然是有效的。</p>
<p>但是另一台服务器接替故障服务器之后，之前的watcher和重连过程中znode发生的变化都会丢失，需要客户端重新设置watcher</p>
</li>
</ol>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><strong>分布式系统的单点故障</strong>：主节点挂了</p>
<p>正常来说，如果master节点挂了，会重新选举一个新master节点，怎么判断主节点挂了呢？</p>
<p>– 传统方式是采用一个备用节点，这个备用节点定期给当前主节点发送ping包，主节点收到ping包以后向备用节点发送回复Ack ，当备用节点收到回复的时候就会认为当前主节点还活着，让他继续提供服务。</p>
<p>但是如果备用节点到主节点的网络有问题会怎么样？</p>
<p>– 备用节点会自动升级成主节点，那从节点就乱了，一部分汇报给了主节点，一部分汇报给了备用节点</p>
<p>最开始提到的，hdfs利用zk来感知节点故障并且进行选举，这个逻辑其实是把“故障转移到了ZooKeeper身上”</p>
<p>那么zk本身就需要保证自己不会出现上面描述的故障</p>
<p>先说一下zk是怎么做的：在master节点下注册比如两个节点，因为zk节点单调递增的属性，就可以用id最小的节点作为当前master节点，同时对其他节点都注册一个对比自己小一的节点的exist watcher。如果当前master节点挂了那么master节点会被删除，那么比master大一的节点会收到事件，并且自动启动master脚本称为master节点</p>
<p>但是如果zk自己只有一个机器，并且zk这个机器挂了呢？</p>
<p>– 那这个分布式系统会自动变成双master系统</p>
<p>所以zk需要首先有可用性和恢复性的保证</p>
<h3 id="ZooKeeper运行模式"><a href="#ZooKeeper运行模式" class="headerlink" title="ZooKeeper运行模式"></a>ZooKeeper运行模式</h3><p>“<strong>独立模式</strong>“(standalone mode)，即只有一个ZooKeeper服务器。这种模式较为简单，比较适合于测试环境，甚至可以在单元测试中采用，但是不能保证高可用性和恢复性。</p>
<p>“<strong>复制模式</strong>“(replicated mode)，ZooKeeper运行于一个计算机集群上，这个计算机集群被称为一个”<strong>集合体</strong>“(ensemble)。</p>
<h3 id="ZooKeeper集群"><a href="#ZooKeeper集群" class="headerlink" title="ZooKeeper集群"></a>ZooKeeper集群</h3><p><img src="/../images/distribution/zk集群.png" alt="zk集群"></p>
<p>ZooKeeper通过<strong>复制</strong>来实现高可用性，只要集合体中<strong>半数以上</strong>的机器处于可用状态，它就能够提供服务。例如，在一个有5个节点的集合体中，每个Follower节点的数据都是Leader节点数据的副本，也就是说我们的每个节点的数据视图都是一样的，这样就可以有五个节点提供ZooKeeper服务。并且集合体中任意2台机器出现故障，都可以保证服务继续，因为剩下的3台机器超过了半数。</p>
<p>ZK集群中每个Server，都保存一份数据副本。Zookeeper使用简单的同步策略，通过以下两条基本保证来实现数据的一致性：</p>
<p>① 全局<strong>串行化</strong>所有的<strong>写操作</strong></p>
<p>​    <strong>读请求</strong>，由每台Server数据库的本地副本来进行服务。</p>
<p>​    <strong>写请求</strong>，需要通过一致性协议来处理：所有写请求都要被转发到一个单独的Server，称作Leader。ZK集群中其他Server 称作Follower，负责接收Leader发来的提议消息，并且对消息转发达成一致。</p>
<p>② 保证<strong>同一客户</strong>端的指令被FIFO执行（以及消息通知的FIFO）</p>
<h4 id="集群可用性"><a href="#集群可用性" class="headerlink" title="集群可用性"></a>集群可用性</h4><p>为什么是半数以上机器呢？</p>
<p>其实所谓的集群是否可用，隐含的意思就是集群是否能选举出一个leader</p>
<p>一般情况下zk的选举用的是 majority quorums的方案：只有当超过一半的follower达成一致的时候，才会选举出leader-&gt;所以建议zk的节点是奇数</p>
<p>那么我们再回头看一下前面说的单点故障下多个master的问题，我们也可以称为脑裂问题，就是因为通信等问题导致一部分节点失去leader的消息，重新选举一个leader之后，网络恢复出现两个leader的问题。那么在zk的场合下我们假设遇到了这个问题，机房A有三台机器，机房B有两台，当机房A和B断连之后：</p>
<p>首先leader和follower之间是有心跳检测的，所以follower会很快判断自己和leader断连了并且进入选举</p>
<ol>
<li>leader是机房A的，那么机房B选不出leader，就会变成不可用的follower，直到网络恢复</li>
<li>leader是机房B的，那么断开之后机房A会选出一个新leader，可以看一下最后的epoch位介绍，每次选一个新leader epoch位都会加一，那么当网络恢复之后，机房A和B的leader在通信的时候会判断epoch是否一致，epoch小的那个会自动重置</li>
</ol>
<p>所以保证了zk集群不会出现脑裂问题，但是在场景2当网络恢复之前也会出现两个leader，所以还需要增加其他方案来保证不会出现脑裂问题</p>
<h3 id="zk与cap"><a href="#zk与cap" class="headerlink" title="zk与cap"></a>zk与cap</h3><p><strong>① 顺序一致性</strong></p>
<p>来自任意特定客户端的更新都会按其发送顺序被提交。也就是说，如果一个客户端将Znode z的值更新为a，在之后的操作中，它又将z的值更新为b，则没有客户端能够在看到z的值是b之后再看到值a（如果没有其他对z的更新）。</p>
<p><strong>② 原子性</strong></p>
<p>每个更新要么成功，要么失败。这意味着如果一个更新失败，则不会有客户端会看到这个更新的结果。</p>
<p><strong>③ 单一系统映像</strong></p>
<p>一 个客户端无论连接到哪一台服务器，它看到的都是同样的系统视图。这意味着，如果一个客户端在同一个会话中连接到一台新的服务器，它所看到的系统状态不会比 在之前服务器上所看到的更老。当一台服务器出现故障，导致它的一个客户端需要尝试连接集合体中其他的服务器时，所有滞后于故障服务器的服务器都不会接受该 连接请求，除非这些服务器赶上故障服务器。</p>
<p><strong>④ 持久性</strong></p>
<p>一个更新一旦成功，其结果就会持久存在并且不会被撤销。这表明更新不会受到服务器故障的影响。</p>
<h3 id="zab协议"><a href="#zab协议" class="headerlink" title="zab协议"></a>zab协议</h3><p>ZAB原名叫做Zookeeper Atomic Broadcast，是一种支持崩溃恢复的原子广播协议。</p>
<p>背景：所有的读都是在follower中处理的，但是写操作都会被转发到leader手上由leader统一处理</p>
<h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><p>所有的事务必须由一个全局唯一的服务器协调处理，这个服务器叫做Leader，其他的服务器称为Follower。Leader服务器将事务转换成Proposal(提议)，并将该提议分发给所有的Follower。Leader等待Follower反馈，一旦<strong>超过半数</strong>正确反馈后，Ledaer将会再次向所有的Follower服务器发送Commit消息，要求将前一个Proposal提交。</p>
<p><img src="/../images/distribution/两次提交.png" alt></p>
<blockquote>
<p>在广播过程中，Leader服务器会首先为这个事务分配一个全局单调递增的唯一ID,我们称之为事务ID(即ZXID)。Leader服务器会为每一个Follower服务器给自分配一个单独队列FIFO。将要广播的事务放到队列中，然后进行消息的发送。每一个Follower接受到事务后，会将其以事务日志的形式写道磁盘，成功后返回ACK消息，当Leader接收到半数以上的ACK后，就会广播一个Commit消息，通知Follower进行事务提交。</p>
</blockquote>
<p>正常的数据更新就是用消息广播来处理的，但是如果leader结点崩溃的话，消息广播并不能解决问题</p>
<h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>当Leader服务与过半的Follower失联，那么就会进入崩溃恢复模式。为了保证集群的正常运行，需要选举出新的Leader，这种叫做崩溃恢复，它不仅要让Leader知道自己是Leader节点，还要让其他的Follower知道他是Leader。</p>
<p>当崩溃恢复选取节点的时候会首先比较事务id(zxid)，举个例子，当Leader发送Commit给其他节点的时候,假如有三个节点A、B、C，其中A收到了，当发送B的时候Ledaer突然崩了，那么新选举出来的节点应该是A，因为A的事务id最大。</p>
<p><strong>恢复原则：</strong></p>
<p><strong>①</strong> 我们绝不能遗忘已经被deliver的消息，若一条消息在一台机器上被<strong>deliver</strong>，那么该消息必须将在每台机器上<strong>deliver</strong>。</p>
<p>方式：其实主要是借助leader选取的是最高zxid这个方案，当 Follower 连接上 Leader 之后，Leader 服务器会根据自己服务器上最后被提交的 ZXID 和 Follower 上的 ZXID 进行比对，比对结果要么回滚，要么和 Leader 同步。</p>
<p><strong>②</strong> 我们必须丢弃已经被skip的消息。</p>
<p>方式：在我们的实现中，<strong>Zxid</strong>是由<strong>64位</strong>数字组成的，<strong>低32</strong>位用作简单<strong>计数器</strong>。<strong>高32位</strong>是一个<strong>epoch</strong>。每当<strong>新Leader接管它时</strong>，将获取日志中Zxid最大的epoch，新Leader <strong>Zxid</strong>的<strong>epoch位</strong>设置为epoch+1，<strong>counter位</strong>设置0。用epoch来标记领导关系的改变,并要求<strong>Quorum Servers</strong> 通过epoch来识别该leader，避免了多个Leader用同一个<strong>Zxid</strong>发布不同的提议。</p>
<p>paxos和zab对比：<a href="https://www.cnblogs.com/wuxl360/p/5817646.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuxl360/p/5817646.html</a></p>
<h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><p>增加observer：简单来说，observer和follower一样作为读服务器，承载读请求，同时把写请求转发给leader</p>
<p>区别：在写请求的时候leader会发起proposal并收集投票，observer不参与接受propose和返回ack的过程，只接收最后的commit结果并同步本地数据</p>
<p>目的：</p>
<ol>
<li>增加可伸缩性</li>
</ol>
<p>我们现在可以加入很多 Observer 节点，而无须担心严重影响写吞吐量。虽然通知commit的阶段的开销还是会随着observer节点增长而增加，但是这里的开销相对来说非常低</p>
<ol start="2">
<li>增加广域网覆盖能力</li>
</ol>
<p>可以把leader和follower这种需要大量通信交互的放在尽量近的网络内，保证往返时延不会太高，同时把observer放在需要访问 ZooKeeper 的任意数据中心中。这样，投票协议不会受到数据中心间链路的高时延的影响，性能得到提升。投票过程中 Observer 和领导节点间的消息远少于投票服务器和领导节点间的消息。这有助于在远程数据中心高写负载的情况下降低带宽需求。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/12/13/刷题碎碎念二：原地交换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/13/刷题碎碎念二：原地交换/" itemprop="url">
                  刷题碎碎念二：原地交换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-12-13 16:39:11 / Modified: 19:57:48" itemprop="dateCreated datePublished" datetime="2023-12-13T16:39:11+08:00">2023-12-13</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>正常交换的时候我们需要用一个临时存储tmp: tmp = a; a = b; b = tmp</p>
<p>怎么原地存储呢？很简单的想法就是用一个差: a = a - b; b = a + b; a = -( a - b )</p>
<p>如果用位运算呢</p>
<p>所以就变成了</p>
<p>a = a ^ b</p>
<p>b = a ^ b</p>
<p>a = b ^ a</p>
<p>利用xor的思路想就很简单很简单</p>
<p>但是本质就是个智力游戏，没有实际用途。。。还不如用一个tmp来的有可读性</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/12/13/找工作TBD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/13/找工作TBD/" itemprop="url">
                  找工作TBD
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-12-13 14:35:48" itemprop="dateCreated datePublished" datetime="2023-12-13T14:35:48+08:00">2023-12-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2023-12-22 17:17:44" itemprop="dateModified" datetime="2023-12-22T17:17:44+08:00">2023-12-22</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>看im逻辑（重要非常重要</li>
<li>去隔壁分析云看一眼新系统</li>
<li>csapp<ol>
<li>SRAM？</li>
<li>补码（看过很多次了再看一次）// DONE</li>
<li>浮点数计算（不重要但是不影响好奇）</li>
<li>多路复用，I/O多路复用</li>
<li>处理器pipeline设计</li>
</ol>
</li>
<li>mysql，mongo和clickhouse</li>
<li>蹭公司的游戏开发框架内部课程看两眼（你司的招牌就是im和游戏了临走总得学一学）</li>
<li>不能因为是通信科班出来的就不复习包括telnet在内的各种计算机网络谢谢</li>
<li>统一配置相关</li>
<li>go prof：现在应该勉强能看懂一些了，可以试着写一个案例来优化</li>
<li>边缘节点</li>
<li>go micro</li>
<li>mq</li>
<li>规则引擎</li>
<li>flink spark etl</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/12/08/剑指offer-memo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/08/剑指offer-memo/" itemprop="url">
                  剑指offer memo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-12-08 17:28:48" itemprop="dateCreated datePublished" datetime="2023-12-08T17:28:48+08:00">2023-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2024-01-10 23:11:18" itemprop="dateModified" datetime="2024-01-10T23:11:18+08:00">2024-01-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数组中重复数字"><a href="#数组中重复数字" class="headerlink" title="数组中重复数字"></a>数组中重复数字</h2><p>题目：<a href="https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/" target="_blank" rel="noopener">https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/</a></p>
<p>解法：</p>
<ol>
<li>hashmap，最容易想到的解法，但是空间复杂度O(n)</li>
<li><p>能改变nums数组的背景下将值对应index的值变为-，重复遇到时值为负，但是会改变数组值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        key := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(num)))</span><br><span class="line">        <span class="keyword">if</span> nums[key] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">        &#125;</span><br><span class="line">        nums[key] = -nums[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二分法：在n个 1-n的数字中有重复，这个问题可以理解为，在数字 1到n/2 和 n/2到n两个范围中，重复数字落下的区间所拥有的数组数字量一定比一半要更多，用这个方式可以对 1-n的数字二分最后找到答案，时间复杂度O(nlogn)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">1</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (left+right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> leftNum,rightNum <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> num &gt; mid &amp;&amp; num &lt;= right &#123;</span><br><span class="line">                rightNum++</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt;= left &amp;&amp; num &lt;= mid &#123;</span><br><span class="line">                leftNum++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> leftNum &lt;= mid - left + <span class="number">1</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>环形链表：数字和对应下标值可以组成一个链表（当然是在数字本身是1-n的背景下），比如数组 [1,3,2,2] 组成的链表就是 1-&gt;3-&gt;2-&gt;2…，最后的2就会变成一个环形链表，可以用快慢指针找环形链表的方案求解，时间复杂度O(n)，空间复杂度O(1) 完美</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fast,slow,start <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        </span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        fast = nums[nums[fast]]</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == slow &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        start = nums[start]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>题目：<a href="https://leetcode.com/problems/search-a-2d-matrix-ii/submissions/1116268925/" target="_blank" rel="noopener">https://leetcode.com/problems/search-a-2d-matrix-ii/submissions/1116268925/</a></p>
<p>没啥老朋友+1，就是从左到右从上到下递增的二维数组怎么找数字</p>
<p>从右上和左下开始的思路是一样的，以从右上开始打个比方，就是</p>
<ul>
<li>如果matrix[a][b] &gt; target，那么对所有x,y, x &gt; a &amp;&amp; y &gt; b，都比target要大，也就是整个右下角，所以可以跳过右下角的遍历</li>
<li>如果matrix[a][b] &lt; target，那么对所有x,y, x &lt; a &amp;&amp; y &lt; b，都比target要小，所以不需要关心左上角</li>
<li>从右上开始的逻辑就是，右上角已经走过了，之后只需要对左下角接着遍历就ok了</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    m := <span class="built_in">len</span>(matrix)</span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line">    y := <span class="built_in">len</span>(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x == m || y &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> matrix[x][y] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> matrix[x][y] &gt; target &#123;</span><br><span class="line">            y --</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p>题目：<a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>老朋友加一，同时知道前序遍历（或后序遍历）和中序遍历就能够唯一确定一颗二叉树，而前序和后序则不能</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur := &amp;TreeNode&#123;</span><br><span class="line">        Val: preorder[<span class="number">0</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> inIndex <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i,in := <span class="keyword">range</span> inorder &#123;</span><br><span class="line">        <span class="keyword">if</span> in == preorder[<span class="number">0</span>] &#123;</span><br><span class="line">            inIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.Left = buildTree(preorder[<span class="number">1</span>:inIndex+<span class="number">1</span>], inorder[<span class="number">0</span>:inIndex])</span><br><span class="line">    cur.Right = buildTree(preorder[inIndex+<span class="number">1</span>:], inorder[inIndex+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用两个栈实现堆"><a href="#用两个栈实现堆" class="headerlink" title="用两个栈实现堆"></a>用两个栈实现堆</h2><p>题目：<a href="https://leetcode.com/problems/implement-queue-using-stacks/submissions/1116341974/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-queue-using-stacks/submissions/1116341974/</a></p>
<p>没什么好讲的+1，写着玩</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    In []<span class="keyword">int</span></span><br><span class="line">    Out []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.In = <span class="built_in">append</span>(this.In, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.Out) == <span class="number">0</span> &#123;</span><br><span class="line">        this.Out = <span class="built_in">append</span>(this.Out, this.In...)</span><br><span class="line">        this.In = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = this.Out[<span class="number">0</span>]</span><br><span class="line">    this.Out = this.Out[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.Out) == <span class="number">0</span> &#123;</span><br><span class="line">        this.Out = <span class="built_in">append</span>(this.Out, this.In...)</span><br><span class="line">        this.In = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.Out[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.Out) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.In) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Peek();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>题目：</p>
<ul>
<li><a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">https://leetcode.com/problems/fibonacci-number/</a></li>
<li><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/description/</a></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多写两步就是爬楼梯，爬楼梯的本质方法其实就是下面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n<span class="number">-1</span>) + climbStairs(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是显而易见这是个递归，时间复杂度O(2^n)，这么简单的问题用递归太消耗时间了（虽然确实很简单），climbStairs(n-1) 和 climbStairs(n-2) 一定遇见过很多次重复计算，如果我们把爬到每层楼梯的计算结果都存下来呢？</p>
<p>下面就是用空间换时间之后的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    steps := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    steps[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    steps[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i&lt;n; i++ &#123;</span><br><span class="line">        steps[i] = steps[i<span class="number">-2</span>] + steps[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞬间就变成了时间O(n)，空间O(n)的东西了</p>
<p>最后我们发现其实每次只关心step[n-1]和step[n-2]，所以就可以简化空间：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    one := <span class="number">1</span></span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line">        two := res</span><br><span class="line">        res += one</span><br><span class="line">        one = two</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>最后总结一下，dp本质上就是用空间换时间，主要的流程分为以下三步：</p>
<ol>
<li>写出递归公式 f(n) = f(n-k)+f(n-w) （简单打个比方）</li>
<li>用空间换时间方法写出dp解法</li>
<li>优化空间</li>
</ol>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>题目：<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/</a></p>
<p>解法就是显而易见的二分法，写二分法的时候我为了看起来舒服所以个人习惯喜欢写递归，这次把迭代递归两种都写一下：<br>递归：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">  &#125;   </span><br><span class="line">  mid := (<span class="number">0</span> + <span class="built_in">len</span>(nums) - <span class="number">1</span> ) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">if</span> nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>] &lt; nums[mid] &#123;</span><br><span class="line">      <span class="keyword">return</span> findMin(nums[mid+<span class="number">1</span>:])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> findMin(nums[<span class="number">0</span>:mid+<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &lt; nums[mid] &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p>题目：<a href="https://leetcode.com/problems/word-search/solutions/2498848/simple-backtracking-with-go/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search/solutions/2498848/simple-backtracking-with-go/</a></p>
<p>典型回溯法求解，一开始天真地写了个外部函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i,row := <span class="keyword">range</span> board &#123;</span><br><span class="line">        <span class="keyword">for</span> j,_ := <span class="keyword">range</span> row &#123;</span><br><span class="line">            res := find(board,word,<span class="number">0</span>,i,j)</span><br><span class="line">            <span class="keyword">if</span> res == <span class="literal">true</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>, wordIndex,x,y <span class="keyword">int</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">        m := <span class="built_in">len</span>(board)</span><br><span class="line">    n := <span class="built_in">len</span>(board[<span class="number">0</span>]) </span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> board[x][y] != []<span class="keyword">byte</span>(word)[wordIndex] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wordIndex == <span class="built_in">len</span>(word) - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    tmp := board[x][y]</span><br><span class="line">    board[x][y] = <span class="keyword">byte</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    wordIndex++</span><br><span class="line">    res := <span class="literal">false</span></span><br><span class="line">        res = find(board,word,wordIndex,x,y + <span class="number">1</span>) || find(board,word,wordIndex,x,y - <span class="number">1</span>) || find(board,word,wordIndex,x<span class="number">-1</span>,y) || find(board,word,wordIndex,x+<span class="number">1</span>,y)</span><br><span class="line">        </span><br><span class="line">    board[x][y] = tmp</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后发现go可以搞闭包：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(board)</span><br><span class="line">    n := <span class="built_in">len</span>(board[<span class="number">0</span>]) </span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(x,y,wordIndex <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(x,y,wordIndex <span class="keyword">int</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> board[x][y] != []<span class="keyword">byte</span>(word)[wordIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> wordIndex == <span class="built_in">len</span>(word) - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        tmp := board[x][y]</span><br><span class="line">        board[x][y] = <span class="keyword">byte</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        wordIndex++</span><br><span class="line">        res := <span class="literal">false</span></span><br><span class="line">        res = backtrack(x,y + <span class="number">1</span>, wordIndex) || backtrack(x,y - <span class="number">1</span>, wordIndex) || backtrack(x<span class="number">-1</span>,y, wordIndex) || backtrack(x+<span class="number">1</span>,y,wordIndex)</span><br><span class="line">            </span><br><span class="line">        board[x][y] = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i,row := <span class="keyword">range</span> board &#123;</span><br><span class="line">        <span class="keyword">for</span> j,_ := <span class="keyword">range</span> row &#123;</span><br><span class="line">            <span class="keyword">if</span> backtrack(i,j,<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p>题目： <a href="https://leetcode.com/problems/number-of-1-bits/solutions/4340903/o-log-n-c-python-java-explained/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-1-bits/solutions/4340903/o-log-n-c-python-java-explained/</a></p>
<p>解法：<br>简单遍历取余，时间复杂度 O(logn)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> time <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num %<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            time++</span><br><span class="line">        &#125;</span><br><span class="line">        num /= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以写成位运算的形式（从计算效率来说位运算肯定比除法好很多）（为什么？）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> time <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        time+= <span class="keyword">int</span>(num%<span class="number">2</span>)</span><br><span class="line">        num &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p>题目：<a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">https://leetcode.com/problems/powx-n/</a></p>
<p>解法：</p>
<ol>
<li>顺着乘起来，时间复杂度是O(n)</li>
<li>假设二进制 n = 1001， $a^n$ = $a^8*a$，可以把时间复杂度降低到 $log_2n$</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> powVal <span class="keyword">float64</span></span><br><span class="line">    powVal = <span class="number">1</span></span><br><span class="line">    newN := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(n)))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> newN==<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> newN &amp; <span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">            powVal *= x</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x</span><br><span class="line">        newN = newN &gt;&gt; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> powVal</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/powVal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在O-1-时间内删除链表节点"><a href="#在O-1-时间内删除链表节点" class="headerlink" title="在O(1)时间内删除链表节点"></a>在O(1)时间内删除链表节点</h2><p>题目：<a href="https://leetcode.com/problems/delete-node-in-a-linked-list/submissions/1117061591/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-node-in-a-linked-list/submissions/1117061591/</a></p>
<p>简单来说考验的就是对链表的熟悉程度</p>
<ol>
<li>一开始想到的方案是把链表整个往左移，所以写了个循环 </li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(node *ListNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"node:%v"</span>,node.Next)</span><br><span class="line">        <span class="keyword">if</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val = node.Next.Val</span><br><span class="line">            <span class="keyword">if</span> node.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">                node.Next = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">break</span>        </span><br><span class="line">            &#125;</span><br><span class="line">            node = node.Next</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>后来发现自己就是个弱智，直接把下一个节点跳过不就行了？题目还强调了那么多次保证不会给末端节点，不审题唉<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(node *ListNode)</span></span> &#123;</span><br><span class="line">    node.Val = node.Next.Val</span><br><span class="line">    node.Next = node.Next.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="删除链表中重复的节点"><a href="#删除链表中重复的节点" class="headerlink" title="删除链表中重复的节点"></a>删除链表中重复的节点</h2><p>题目：<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/</a></p>
<p>自己写的时候多绕了一层，判断是否重复，然后再挨个判断<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    newHead := &amp;ListNode&#123;</span><br><span class="line">        Val: <span class="number">-101</span>,</span><br><span class="line">        Next : head,</span><br><span class="line">    &#125;</span><br><span class="line">    cur := newHead</span><br><span class="line">    before := <span class="number">-101</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cur.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cur.Next.Val == before &#123;</span><br><span class="line">            cur.Next = cur.Next.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> cur.Next.Next != <span class="literal">nil</span> &amp;&amp; cur.Next.Val == cur.Next.Next.Val &#123;</span><br><span class="line">            before = cur.Next.Val</span><br><span class="line">            cur.Next = cur.Next.Next.Next</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以把每个节点内加个判断重复的循环就行了，性能差不多但是代码可读性和理解会更简单一点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    newHead := &amp;ListNode&#123;</span><br><span class="line">        Val: <span class="number">-101</span>,</span><br><span class="line">        Next : head,</span><br><span class="line">    &#125;</span><br><span class="line">    cur := head</span><br><span class="line">    before := newHead</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> count <span class="keyword">int</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.Next == <span class="literal">nil</span> ||cur.Next.Val != cur.Val &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.Next</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            before.Next = cur</span><br><span class="line">            before = cur</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    before.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>题目：<a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/</a></p>
<p>经典dp题，做了好一阵子</p>
<p>首先写出dp公式，一开始的时候写出来是这样的：</p>
<ul>
<li>假设 i:字符串index,j:正则index</li>
<li>当p[j] 不等于 ‘*’ 时，dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i] = p[j] || p[j] = ‘.’)</li>
<li>当p[j] 等于 ‘*’ 时，dp[i][j] = (s[i] = p[j-1] || p[j-1] = ‘.’) &amp;&amp; (dp[i-1][j-1] || dp[i-1][j])</li>
</ul>
<p>美滋滋写完发现报错了，忽略了一种场景：input= “aab”, regx = “c*a*b”，也就是”c*“不是”c+”，没有字符也是ok的</p>
<p>所以在这个的基础上针对输入加了第0位，也就是空字符串的正则表达匹配，最后的公式等于：</p>
<ul>
<li>假设 i:字符串index,j:正则index</li>
<li>当p[j] 不等于 ‘*’ 时，dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i] = p[j] || p[j] = ‘.’)</li>
<li>当p[j] 等于 ‘*’ 时，dp[i][j] = (s[i] = p[j-1] || p[j-1] = ‘.’) &amp;&amp; (dp[i-1][j-1] || dp[i-1][j]) || <strong>dp[i][j-2]</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dps [][]<span class="keyword">bool</span></span><br><span class="line">    m := <span class="built_in">len</span>(s)</span><br><span class="line">    n := <span class="built_in">len</span>(p)</span><br><span class="line">    dps = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> d:= <span class="number">0</span>; d&lt; m+<span class="number">1</span>; d++ &#123;</span><br><span class="line">        dps[d] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dps[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span>  i:=<span class="number">0</span>; i&lt;=m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>;j&lt;=n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> p[j<span class="number">-1</span>] != <span class="string">'*'</span> &#123;</span><br><span class="line">                dps[i][j] = i &gt; <span class="number">0</span> &amp;&amp; dps[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>]  == <span class="string">'.'</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dps[i][j] = (i &gt; <span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>]  == <span class="string">'.'</span>) &amp;&amp; (dps[i<span class="number">-1</span>][j] || dps[i<span class="number">-1</span>][j<span class="number">-1</span>])) || dps[i][j<span class="number">-2</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dps[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合法数值字符串"><a href="#合法数值字符串" class="headerlink" title="合法数值字符串"></a>合法数值字符串</h2><p>题目：<a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-number/</a></p>
<p>解法：</p>
<ol>
<li><p>本能用了有限状态自动机来做：</p>
<ul>
<li>状态0:字符串开始和结束</li>
<li>状态1:符号</li>
<li>状态2:数字</li>
<li>状态3:e和E</li>
<li>状态4:前面没有出现过数字的.</li>
<li>状态5:前面出现过数字的.<br>然后构建了一个状态转移矩阵，不过因为其实需要处理的特殊场景比较多（比如E和.只能出现一次），所以还是出现了不少if else判断，其实也可以把这些if else都转成其他状态，但是懒了这样也挺好<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isNumber</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    trans :=[<span class="number">6</span>][<span class="number">6</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> hasE,hasPoint,hasVal <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">var</span> preStatus <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _,val := <span class="keyword">range</span> s&#123;</span><br><span class="line">        <span class="keyword">var</span> status = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">'-'</span>|| val == <span class="string">'+'</span>&#123;</span><br><span class="line">            status = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> val &gt;= <span class="string">'0'</span> &amp;&amp; val &lt;= <span class="string">'9'</span> &#123;</span><br><span class="line">            status = <span class="number">2</span></span><br><span class="line">            hasVal = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> val == <span class="string">'.'</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> hasPoint &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> hasVal &#123;</span><br><span class="line">                status = <span class="number">5</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status = <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            hasPoint = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> val == <span class="string">'E'</span> || val == <span class="string">'e'</span> &#123;</span><br><span class="line">            status = <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> hasE &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            hasE = <span class="literal">true</span></span><br><span class="line">            hasPoint = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> trans[preStatus][status] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        preStatus = status</span><br><span class="line">    &#125;</span><br><span class="line">    status := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> trans[preStatus][status] == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>正则，当然是个很不错的解法 <code>const regex Solution::pattern(&quot;[+-]?(?:\\d+\\.?\\d*|\\.\\d+)(?:[Ee][+-]?\\d+)?&quot;)</code> 但是y1s1对正则真的不是特别熟练。。。</p>
</li>
</ol>
<h2 id="按奇偶排序数组"><a href="#按奇偶排序数组" class="headerlink" title="按奇偶排序数组"></a>按奇偶排序数组</h2><p>题目：<a href="https://leetcode.com/problems/sort-array-by-parity/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-array-by-parity/</a></p>
<p>非常典型的双指针题，遍历都是一遍过没有问题<br>解法：</p>
<ol>
<li><p>分配一个新的数组存，空间复杂度会变成O(n)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArrayByParity</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, end+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _,num:= <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            res[start] = num</span><br><span class="line">            start++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[end] = num</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原地交换，空间复杂度O(1)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArrayByParity</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[start]%<span class="number">2</span> ==  &amp;&amp; start &lt; end&#123;</span><br><span class="line">                start++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[end]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; end &gt; start&#123;</span><br><span class="line">                end--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp := nums[start]</span><br><span class="line">            nums[start] = nums[end]</span><br><span class="line">            nums[end] = tmp</span><br><span class="line">            start++</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="链表中倒数第n个节点"><a href="#链表中倒数第n个节点" class="headerlink" title="链表中倒数第n个节点"></a>链表中倒数第n个节点</h2><p>题目：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p>
<p>没啥，前后指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    newHead := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    start := newHead</span><br><span class="line">    end := newHead</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        start = start.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> start.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            start = start.Next</span><br><span class="line">            end = end.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end.Next = end.Next.Next</span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表环入口"><a href="#链表环入口" class="headerlink" title="链表环入口"></a>链表环入口</h2><p>题目：<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/</a><br>解法见第一题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line">    <span class="keyword">var</span> step <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || slow == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> || slow == <span class="literal">nil</span> || fast.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> step == <span class="number">0</span> || fast != slow &#123;</span><br><span class="line">            fast = fast.Next.Next</span><br><span class="line">            slow = slow.Next</span><br><span class="line">            step++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 肯定有环，找入口就行</span></span><br><span class="line">    start := head</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start != slow &#123;</span><br><span class="line">            start = start.Next</span><br><span class="line">            slow = slow.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>题目：<a href="https://leetcode.com/problems/reverse-linked-list/solutions/3211778/using-2-methods-iterative-recursive-beats-97-91/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/solutions/3211778/using-2-methods-iterative-recursive-beats-97-91/</a></p>
<p>老朋友了+1，没什么好说的，写了两种解法：</p>
<ol>
<li><p>循环迭代，时间复杂度O(n)，空间复杂度 O(1)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    newHead := &amp;ListNode&#123;</span><br><span class="line">        Next:<span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">            old := newHead.Next</span><br><span class="line">            newHead.Next = head</span><br><span class="line">            head = head.Next</span><br><span class="line">            newHead.Next.Next = old</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归：时间复杂度O(n)，空间复杂度 O(n)（函数调用空间）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    newHead := reverseList(head.Next)</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> newHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h2><p>题目：<a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/</a></p>
<p>不优雅但好理解，好理解最重要～<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(list1 *ListNode, list2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    newHead := &amp;ListNode&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    head := newHead</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> list1 == <span class="literal">nil</span> &amp;&amp; list2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> list1.Val &lt; list2.Val &#123;</span><br><span class="line">            head.Next = list1</span><br><span class="line">            list1 = list1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.Next = list2</span><br><span class="line">            list2 = list2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left *ListNode </span><br><span class="line">    <span class="keyword">if</span> list1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        left = list1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = list2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left != <span class="literal">nil</span> &#123;</span><br><span class="line">            head.Next = left</span><br><span class="line">            head = head.Next</span><br><span class="line">            left = left.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="判断是否子树"><a href="#判断是否子树" class="headerlink" title="判断是否子树"></a>判断是否子树</h2><p>题目：<a href="https://leetcode.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/subtree-of-another-tree/</a></p>
<p>题解：</p>
<p>我自己写的时候思路是把判断是子树往下走的逻辑和找子树的逻辑混在一块写了，用isSub来判断是在判断子树部分是否一致还是在找子树，这样不是很好看懂还有一堆判断逻辑<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(root *TreeNode, subRoot *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> findSub(root,subRoot,<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSub</span> <span class="params">(root *TreeNode, subRoot *TreeNode, isSub <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &amp;&amp; subRoot == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || subRoot == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> root.Val == subRoot.Val &#123;</span><br><span class="line">        res = findSub(root.Left,subRoot.Left, <span class="literal">true</span>) &amp;&amp; findSub(root.Right,subRoot.Right, <span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> isSub &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !isSub &#123;</span><br><span class="line">        res = res || findSub(root.Left,subRoot, <span class="literal">false</span>) || findSub(root.Right,subRoot, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把判断是否一致的逻辑单独拆出来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(root *TreeNode, subRoot *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || subRoot == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == subRoot</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isIdentical(root,subRoot) || isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isIdentical</span> <span class="params">(root *TreeNode, subRoot *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || subRoot == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == subRoot</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> root.Val == subRoot.Val &#123;</span><br><span class="line">        res = isIdentical(root.Left,subRoot.Left) &amp;&amp; isIdentical(root.Right,subRoot.Right)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>题目：<a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/description/</a></p>
<p>解法：</p>
<ol>
<li><p>dfs递归，说实话递归没啥好写的，就是个普通的递归就结束了（所以说人类爱写递归不是没有原因的，太好写也太好懂了虽然占地方）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> right,left *TreeNode</span><br><span class="line">    right = invertTree(root.Left)</span><br><span class="line">    left = invertTree(root.Right)</span><br><span class="line">    root.Left = left</span><br><span class="line">    root.Right = right</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bfs，用队列来遍历二叉树，以后经常会这么做，习惯就好</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> stack []*TreeNode</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        l := <span class="built_in">len</span>(stack)</span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        head := stack[l - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:l<span class="number">-1</span>]</span><br><span class="line">        tmp := head.Right</span><br><span class="line">        head.Right = head.Left</span><br><span class="line">        head.Left = tmp</span><br><span class="line">        <span class="keyword">if</span> head.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, head.Right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> head.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, head.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><p>题目：<a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a></p>
<p>当然肯定有用堆来做的解法，一样一样的，偷懒不想写了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> symmetric(root.Left, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">symmetric</span><span class="params">(left *TreeNode, right *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left == right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left.Val == right.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> symmetric(left.Left, right.Right) &amp;&amp;  symmetric(left.Right, right.Left)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>题目：<a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/spiral-matrix/</a></p>
<p>题解：设置上下左右边界，按照边界进行遍历就行，时间复杂度O(mn)，空间复杂度O(1)，因为只需要记录四个边界</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left,right,up,down <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">    right = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    down = <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left &gt; right || up &gt; down &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i:= left; i &lt;= right; i++ &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, matrix[up][i])</span><br><span class="line">        &#125;</span><br><span class="line">        up++</span><br><span class="line">        <span class="keyword">for</span> i:= up; i&lt;= down; i++ &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, matrix[i][right])</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        right--</span><br><span class="line">        <span class="keyword">if</span> up &lt;= down &#123;</span><br><span class="line">            <span class="keyword">for</span> i:= right; i &gt;= left; i-- &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, matrix[down][i])</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            down--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left &lt;= right &#123;</span><br><span class="line">            <span class="keyword">for</span> i:= down; i&gt;= up; i-- &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, matrix[i][left])</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="min-stack"><a href="#min-stack" class="headerlink" title="min stack"></a>min stack</h2><p>题目：<a href="https://leetcode.com/problems/min-stack/submissions/1117973116/" target="_blank" rel="noopener">https://leetcode.com/problems/min-stack/submissions/1117973116/</a></p>
<p>解法：</p>
<ol>
<li><p>辅助栈。时间复杂度O(1)，空间复杂度O(n)，简单来说就是搞个辅助栈minStack，利用栈先进后出的特性保存当前栈的最小值（一开始把栈和堆搞反了怎么也做不出来）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack []<span class="keyword">int</span></span><br><span class="line">    minStack []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.stack = <span class="built_in">append</span>(this.stack,val)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.minStack) &gt; <span class="number">0</span> &amp;&amp;  this.minStack[<span class="built_in">len</span>(this.minStack) - <span class="number">1</span>] &lt; val &#123;</span><br><span class="line">        this.minStack = <span class="built_in">append</span>(this.minStack, this.minStack[<span class="built_in">len</span>(this.minStack) - <span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.minStack = <span class="built_in">append</span>(this.minStack, val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    this.minStack = this.minStack[<span class="number">0</span>:<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">GetMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>空间复杂度为O(1)的辅助栈：受到了一点题解的启发，用和最小值的差值而不是当前值来保存，不过说实话这么难以阅读的逻辑不要也罢</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack []<span class="keyword">int</span></span><br><span class="line">    min <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;</span><br><span class="line">        min:<span class="number">-1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.stack) == <span class="number">0</span> &#123;</span><br><span class="line">        this.min = val</span><br><span class="line">    &#125;</span><br><span class="line">    diff := val - this.min</span><br><span class="line">    this.stack = <span class="built_in">append</span>(this.stack,diff)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> diff &lt; <span class="number">0</span>&#123;</span><br><span class="line">        this.min = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    val := this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> val &lt; <span class="number">0</span> &#123;</span><br><span class="line">        this.min -= val</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    val := this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> val &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> this.min</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val + this.min</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">GetMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="判断栈压入弹出序列合法"><a href="#判断栈压入弹出序列合法" class="headerlink" title="判断栈压入弹出序列合法"></a>判断栈压入弹出序列合法</h2><p>题目：<a href="https://leetcode.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">https://leetcode.com/problems/validate-stack-sequences/</a></p>
<p>题解：其实就是模拟栈来处理</p>
<ol>
<li>空间复杂度O(1)但是修改原数组，因为不是很清楚go的删除节点是不是要O(n)一下，所以非常不建议</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateStackSequences</span><span class="params">(pushed []<span class="keyword">int</span>, popped []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i,j <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(pushed) &#123;</span><br><span class="line">            <span class="keyword">return</span> i == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">-1</span> || pushed[i] != popped[j] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp := pushed[i+<span class="number">1</span>:]</span><br><span class="line">            pushed = <span class="built_in">append</span>(pushed[:i], tmp...)</span><br><span class="line">            j++</span><br><span class="line">            i--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用辅助数组来模拟栈的操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateStackSequences</span><span class="params">(pushed []<span class="keyword">int</span>, popped []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> help []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _,val := <span class="keyword">range</span> pushed &#123;</span><br><span class="line">        help = <span class="built_in">append</span>(help, val)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(help) &gt; <span class="number">0</span> &amp;&amp; popped[i] == help[<span class="built_in">len</span>(help) - <span class="number">1</span>] &#123;</span><br><span class="line">                help = help[:<span class="built_in">len</span>(help) - <span class="number">1</span>]</span><br><span class="line">                i++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(help) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="分行从上到下打印二叉树"><a href="#分行从上到下打印二叉树" class="headerlink" title="分行从上到下打印二叉树"></a>分行从上到下打印二叉树</h2><p>题目：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/submissions/1118009830/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/submissions/1118009830/</a></p>
<p>题解：用堆就结束了，时间和空间复杂度都是O(n)，除了go不提供堆这种数据结构之外没有什么难点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> heap []*TreeNode</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    heap = <span class="built_in">append</span>(heap, root)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp := heap</span><br><span class="line">        heap = []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">var</span> resTmp []<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> _,node := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">            resTmp = <span class="built_in">append</span>(resTmp, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                heap = <span class="built_in">append</span>(heap, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                heap = <span class="built_in">append</span>(heap, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, resTmp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分行之字打印二叉树"><a href="#分行之字打印二叉树" class="headerlink" title="分行之字打印二叉树"></a>分行之字打印二叉树</h2><p>题目：<a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a></p>
<p>和上题差不多就是个欢乐堆bfs</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> heap []*TreeNode</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    heap = <span class="built_in">append</span>(heap, root)</span><br><span class="line">    inOrder := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp := heap</span><br><span class="line">        heap = []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">var</span> tmpRes []<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> i:= <span class="built_in">len</span>(tmp) <span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">            node := tmp[i]</span><br><span class="line">            tmpRes = <span class="built_in">append</span>(tmpRes, node.Val)</span><br><span class="line">            <span class="keyword">if</span> inOrder &#123;</span><br><span class="line">                <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    heap = <span class="built_in">append</span>(heap, node.Left)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    heap = <span class="built_in">append</span>(heap, node.Right)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    heap = <span class="built_in">append</span>(heap, node.Right)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    heap = <span class="built_in">append</span>(heap, node.Left)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder = !inOrder</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmpRes)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断二叉搜索树后续遍历合法"><a href="#判断二叉搜索树后续遍历合法" class="headerlink" title="判断二叉搜索树后续遍历合法"></a>判断二叉搜索树后续遍历合法</h2><p>（leetcode要钱所以去了牛客）题目：<a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p>二叉搜索树：根节点内所有左子树值\&lt;root，所有右子树值> root</p>
<p>解法递归本身没什么问题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifySquenceOfBST</span><span class="params">( sequence []<span class="keyword">int</span> )</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sequence) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">var</span> checkRight <span class="function"><span class="keyword">func</span><span class="params">(left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">    checkRight = <span class="function"><span class="keyword">func</span><span class="params">(left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        rootVal := sequence[right]</span><br><span class="line">        <span class="keyword">var</span> i = right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> ; i&gt;= left; i-- &#123;</span><br><span class="line">            <span class="keyword">if</span> sequence[i] &lt; rootVal &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j:=left;j&lt;=i;j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> sequence[j] &gt;= rootVal &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkRight(left, i) &amp;&amp; checkRight(i+<span class="number">1</span>,right<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> checkRight(<span class="number">0</span>,<span class="built_in">len</span>(sequence) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><p>题目：<a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/</a></p>
<p>题解：</p>
<ol>
<li><p>简单dfs</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> checkVal <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>, before []<span class="keyword">int</span>)</span></span> </span><br><span class="line">    checkVal = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, nowSum <span class="keyword">int</span>, before []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        nowSum += root.Val </span><br><span class="line">        before = <span class="built_in">append</span>(before, root.Val)</span><br><span class="line">        <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nowSum == targetSum &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, before...))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        checkVal(root.Left, nowSum, before)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        checkVal(root.Right, nowSum, before)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    checkVal(root,<span class="number">0</span>,[]<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用回溯法优化路径存储，只要有一个path就行不需要传参</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> path []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> checkVal <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span></span> </span><br><span class="line">    checkVal = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, nowSum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        nowSum += root.Val </span><br><span class="line">        path = <span class="built_in">append</span>(path, root.Val)</span><br><span class="line">        <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nowSum == targetSum &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, path...))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                checkVal(root.Left, nowSum)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                checkVal(root.Right, nowSum)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    checkVal(root,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h2><p>题目：<a href="https://leetcode.com/problems/copy-list-with-random-pointer/submissions/1118858301/" target="_blank" rel="noopener">https://leetcode.com/problems/copy-list-with-random-pointer/submissions/1118858301/</a></p>
<p>解法：</p>
<ol>
<li><p>用hash保存已经创建的链表（面试答不出来就用这个方法），空间复杂度是O(n)，时间复杂度O(n)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    nodeMap := <span class="keyword">map</span>[*Node]*Node&#123;&#125;</span><br><span class="line">    cur := &amp;Node&#123;</span><br><span class="line">        Val: head.Val,</span><br><span class="line">    &#125;</span><br><span class="line">    newNode := &amp;Node &#123;</span><br><span class="line">        Next: cur,</span><br><span class="line">    &#125;</span><br><span class="line">    nodeMap[head] = cur</span><br><span class="line">    nodeMap[<span class="literal">nil</span>] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> next,ok := nodeMap[head.Next]; ok &#123;</span><br><span class="line">            cur.Next = next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next :=&amp;Node&#123;</span><br><span class="line">                Val: head.Next.Val,</span><br><span class="line">            &#125;</span><br><span class="line">            nodeMap[head.Next] = next</span><br><span class="line">            cur.Next = next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rand,ok := nodeMap[head.Random]; ok &#123;</span><br><span class="line">            cur.Random = rand</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rad :=&amp;Node&#123;</span><br><span class="line">                Val: head.Random.Val,</span><br><span class="line">            &#125;</span><br><span class="line">            nodeMap[head.Random] = rad</span><br><span class="line">            cur.Random = rad</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur.Next</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原地复制链表，从1-&gt;2-&gt;3 变成 1-&gt;1<em>-&gt;2-&gt;2</em>-&gt;3-&gt;3*，再去进行random赋值和链表拆分，所以一共有三个循环</p>
<ol>
<li>原地复制当前节点，组成复制后链表</li>
<li>复制后节点的random指向</li>
<li>拆开两个链表</li>
</ol>
</li>
</ol>
<p>最后的时间复杂度:O(n)，空间复杂度O(1)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    newNode := &amp;Node&#123;</span><br><span class="line">        Next:head,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        next := &amp;Node&#123;</span><br><span class="line">            Val:head.Val,</span><br><span class="line">            Next:head.Next,</span><br><span class="line">        &#125;</span><br><span class="line">        head.Next = next</span><br><span class="line">        head = next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head = newNode.Next</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> head.Random != <span class="literal">nil</span> &#123;</span><br><span class="line">            head.Next.Random = head.Random.Next</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    head = newNode.Next  </span><br><span class="line">    newHead := head.Next</span><br><span class="line">    newH := newHead</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        </span><br><span class="line">        head.Next = newHead.Next</span><br><span class="line">        head = head.Next</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span>  &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        newHead.Next = head.Next</span><br><span class="line">        newHead = newHead.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="双向链表转二叉搜索树"><a href="#双向链表转二叉搜索树" class="headerlink" title="双向链表转二叉搜索树"></a>双向链表转二叉搜索树</h2><p>题目：<a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
<p>题解：</p>
<ol>
<li>用数组存中序遍历的结果，然后再重新组装（空间复杂度O(n)）（不想写了</li>
<li><p>原地处理数组，我写的方法好像比较复杂一点，不过性能一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convert</span><span class="params">( pRootOfTree *TreeNode )</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> pRootOfTree == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    left := pRootOfTree</span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        left = convLeft(pRootOfTree.Left, pRootOfTree)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        convRight(pRootOfTree.Right, pRootOfTree)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convLeft</span><span class="params">( pRootOfTree *TreeNode , before *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    left := pRootOfTree</span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        left = convLeft(pRootOfTree.Left,pRootOfTree)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        right := convRight(pRootOfTree.Right,pRootOfTree)</span><br><span class="line">        before.Left = right</span><br><span class="line">        right.Right = before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        before.Left = pRootOfTree</span><br><span class="line">        pRootOfTree.Right = before</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convRight</span><span class="params">( pRootOfTree *TreeNode, before *TreeNode )</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    right := pRootOfTree</span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := convLeft(pRootOfTree.Left,pRootOfTree)</span><br><span class="line">        before.Right = left</span><br><span class="line">        left.Left = before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        before.Right = pRootOfTree</span><br><span class="line">        pRootOfTree.Left = before</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        right = convRight(pRootOfTree.Right,pRootOfTree)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以先找到最左的开始节点，再中序遍历就行了，符合中序遍历的核心思想</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convert</span><span class="params">( pRootOfTree *TreeNode )</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> pRootOfTree == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left = pRootOfTree</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = left.Left</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> preNode *TreeNode</span><br><span class="line">    <span class="keyword">var</span> inOrder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    inOrder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.Left)</span><br><span class="line">        root.Left = preNode</span><br><span class="line">        <span class="keyword">if</span> preNode != <span class="literal">nil</span> &#123;</span><br><span class="line">            preNode.Right = root</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = root</span><br><span class="line">        inOrder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(pRootOfTree)</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h2><p>题目：<a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/serialize-and-deserialize-binary-tree/</a></p>
<p>解法：</p>
<ol>
<li><p>bfs用堆，按行遍历，只要不是叶子结点并且有null 子项就输出null，反正主打一个不在乎时间空间优化，hard嘛写出来就算胜利</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Codec <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Codec</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Codec&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Serializes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">serialize</span><span class="params">(root *TreeNode)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resStr <span class="keyword">string</span></span><br><span class="line">    isLeaf := this.isLeaf(root)</span><br><span class="line">    <span class="keyword">var</span>    pops []*TreeNode</span><br><span class="line"></span><br><span class="line">    pops = <span class="built_in">append</span>(pops, root)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pops) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            tmp := pops </span><br><span class="line">            pops = []*TreeNode&#123;&#125;</span><br><span class="line">            newLeaf := <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span> _,node := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">                resStr += <span class="string">","</span></span><br><span class="line">                <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">                    resStr +=  <span class="string">"nil"</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resStr +=strconv.Itoa(node.Val)</span><br><span class="line">                    <span class="keyword">if</span> !isLeaf &#123;</span><br><span class="line">                        pops = <span class="built_in">append</span>(pops, node.Left)</span><br><span class="line">                        pops = <span class="built_in">append</span>(pops, node.Right)</span><br><span class="line">                        newLeaf = newLeaf &amp;&amp; this.isLeaf(node.Left) &amp;&amp; this.isLeaf(node.Right)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            isLeaf = newLeaf</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resStr[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">isLeaf</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  root == <span class="literal">nil</span> || (root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deserializes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Codec)</span> <span class="title">deserialize</span><span class="params">(data <span class="keyword">string</span>)</span> *<span class="title">TreeNode</span></span> &#123;    </span><br><span class="line">    list := strings.Split(data, <span class="string">","</span>)</span><br><span class="line">    <span class="keyword">var</span>    pops []*TreeNode</span><br><span class="line">    <span class="keyword">var</span> root *TreeNode</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(list) == <span class="number">1</span> &amp;&amp; list[<span class="number">0</span>] == <span class="string">"nil"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line">    val,_ := strconv.Atoi(list[<span class="number">0</span>])</span><br><span class="line">    root = &amp;TreeNode&#123;Val:val&#125;</span><br><span class="line">    pops = <span class="built_in">append</span>(pops,root)</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    l := <span class="built_in">len</span>(list)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pops) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            tmp := pops </span><br><span class="line">            pops = []*TreeNode&#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> _,node := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">                <span class="keyword">if</span> i &lt; l - <span class="number">1</span> &#123;</span><br><span class="line">                    left := list[i]</span><br><span class="line">                    right := list[i+<span class="number">1</span>]</span><br><span class="line">                    i += <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> left != <span class="string">"nil"</span> &#123;</span><br><span class="line">                        leftVal,_ := strconv.Atoi(left)</span><br><span class="line">                        ll := &amp;TreeNode&#123;</span><br><span class="line">                            Val:leftVal,</span><br><span class="line">                        &#125;</span><br><span class="line">                        node.Left = ll</span><br><span class="line">                        pops = <span class="built_in">append</span>(pops, ll)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> right != <span class="string">"nil"</span> &#123;</span><br><span class="line">                        rightVal,_ := strconv.Atoi(right)</span><br><span class="line">                        rr := &amp;TreeNode&#123;</span><br><span class="line">                            Val:rightVal,</span><br><span class="line">                        &#125;</span><br><span class="line">                        node.Right = rr</span><br><span class="line">                        pops = <span class="built_in">append</span>(pops, rr)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去参观一下题解，感觉核心思路大差不差放弃治疗就这样吧hard嘛，能写出来就不错了</p>
</li>
</ol>
<h2 id="字符串全排列"><a href="#字符串全排列" class="headerlink" title="字符串全排列"></a>字符串全排列</h2><p>题目：<a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/description/</a></p>
<p>解法：</p>
<ol>
<li><p>回溯没有什么好说的，但是我写的时候偷懒，是用了设置成11的方式来处理已经使用过的数字，这样的问题是时间复杂度会变成：O(n^n)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="keyword">int</span></span><br><span class="line">    l := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> per <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    per = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == l &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res ,<span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, path...))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">11</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = <span class="number">11</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, num)</span><br><span class="line">            per()</span><br><span class="line">            nums[i] = num</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    per()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我每次都把已经处理过的交换到前面，没处理的交换到后面，那时间复杂度就会变成O(n*n!)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="keyword">int</span></span><br><span class="line">    l := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">var</span> per <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>)</span></span></span><br><span class="line">    per = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == l &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res ,<span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, path...))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i:= start; i&lt;l; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            nums[i], nums[start] = nums[start],nums[i]</span><br><span class="line">            per(start+<span class="number">1</span>)</span><br><span class="line">            nums[i], nums[start] = nums[start],nums[i]</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    per(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接递归能做么，当然可以有什么不可以的，但是每次都要把新的nums数组作为参数传进去，刚学过call的堆栈调用想想就很可怕</p>
</li>
</ol>
<h2 id="全排列2（有重复元素）"><a href="#全排列2（有重复元素）" class="headerlink" title="全排列2（有重复元素）"></a>全排列2（有重复元素）</h2><p>题目：<a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations-ii/</a></p>
<p>有重复元素场景的全排列，如果没记错的话当初我应该是搞了个map嗯</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> per <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>)</span></span> </span><br><span class="line">    l := <span class="built_in">len</span>(nums)</span><br><span class="line">    per = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        valMap := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == l &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, path...))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i:= start; i&lt;l; i++ &#123;</span><br><span class="line">            num := nums[i]</span><br><span class="line">            <span class="keyword">if</span> _,ok := valMap[num]; ok &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            valMap[num] = <span class="literal">true</span></span><br><span class="line">            path = <span class="built_in">append</span>(path, num)</span><br><span class="line">            nums[i], nums[start] = nums[start], nums[i]</span><br><span class="line">            per(start + <span class="number">1</span>)</span><br><span class="line">            nums[i], nums[start] = nums[start], nums[i]</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    per(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>题目：<a href="https://leetcode.com/problems/combinations/description/" target="_blank" rel="noopener">https://leetcode.com/problems/combinations/description/</a></p>
<p>顺手就用剪枝+回溯给做了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> path []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> list <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>)</span></span></span><br><span class="line">    list = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i:= start; i&lt;=n ; i++ &#123;</span><br><span class="line">            path = <span class="built_in">append</span>(path, i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == k &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, path...))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list(i+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><p>题目：<a href="https://leetcode.com/problems/majority-element/submissions/1119582289/" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/submissions/1119582289/</a></p>
<p>解法：</p>
<ol>
<li>排序，不想写也不是什么最优解，时间复杂度O(nlogn)，空间复杂度O(1)</li>
<li>搞个map计算出现次数，时间复杂度O(n)，空间复杂度O(n)<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)/<span class="number">2</span></span><br><span class="line">    numsMap := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := numsMap[num]; !ok &#123;</span><br><span class="line">            numsMap[num] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        numsMap[num]++</span><br><span class="line">        <span class="keyword">if</span> numsMap[num] &gt; n &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.摩尔计数法，很有意思的东西，简单来说就是两个王国之间打架，一换一，人数多的那里赢。现在因为有一个数字是过半的，所以不一样的数字就一换一抵消，最后剩下的一定是过半的数字,时间复杂度O(n)，空间复杂度O(1)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maj := nums[<span class="number">0</span>]</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> maj == num &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            maj = num</span><br><span class="line">            count++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.分治，把一堆数字分成两部分，则所求的数字一定是这两部分的众数之一，再合并求这堆的众数，时间复杂度O(nlogn)，空间复杂度O(1)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span>  maxCnt =  <span class="function"><span class="keyword">func</span><span class="params">(lo <span class="keyword">int</span>, up <span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="params">(count <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i:= lo; i&lt;= up; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] == val &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">var</span> maj <span class="function"><span class="keyword">func</span><span class="params">(lo <span class="keyword">int</span>, up <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">    maj =  <span class="function"><span class="keyword">func</span><span class="params">(lo <span class="keyword">int</span>, up <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> lo == up &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[lo]</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (lo + up) / <span class="number">2</span></span><br><span class="line">        left := maj(lo,mid)</span><br><span class="line">        right := maj(mid+<span class="number">1</span>,up)</span><br><span class="line">        <span class="keyword">if</span> left == right &#123;</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">map</span>[<span class="keyword">bool</span>]<span class="keyword">int</span>&#123;<span class="literal">true</span>:left, <span class="literal">false</span>:right&#125;[maxCnt(lo,up, left) &gt; maxCnt(lo,up, right)]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maj(<span class="number">0</span>,<span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最大的k个数"><a href="#最大的k个数" class="headerlink" title="最大的k个数"></a>最大的k个数</h2><p>题目：<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/submissions/1119616730/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/submissions/1119616730/</a></p>
<p>解法：</p>
<ol>
<li>最小堆嘛，老朋友了</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> heap []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) &lt; k &#123;</span><br><span class="line">            heap = <span class="built_in">append</span>(heap, num)</span><br><span class="line">            construct(&amp;heap, <span class="built_in">len</span>(heap))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> num &lt; heap[<span class="number">0</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heap[<span class="number">0</span>] = num</span><br><span class="line">                update(&amp;heap,<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">construct</span><span class="params">(heap *[]<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    val := (*heap)[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        father := (*heap)[(n<span class="number">-1</span>)/<span class="number">2</span> - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> val &lt; father &#123;</span><br><span class="line">             (*heap)[n<span class="number">-1</span>], (*heap)[(n<span class="number">-1</span>)/<span class="number">2</span> - <span class="number">1</span>] = (*heap)[(n<span class="number">-1</span>)/<span class="number">2</span> - <span class="number">1</span>], (*heap)[n<span class="number">-1</span>]</span><br><span class="line">             n = (n<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">             construct(heap, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        father := (*heap)[n/<span class="number">2</span> - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> val &lt; father &#123;</span><br><span class="line">             (*heap)[n<span class="number">-1</span>], (*heap)[n/<span class="number">2</span> - <span class="number">1</span>] = (*heap)[n/<span class="number">2</span> - <span class="number">1</span>], (*heap)[n<span class="number">-1</span>]</span><br><span class="line">             n = n/<span class="number">2</span></span><br><span class="line">             construct(heap, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(heap *[]<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n*<span class="number">2</span> &gt; <span class="built_in">len</span>(*heap) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    val := (*heap)[n<span class="number">-1</span>]</span><br><span class="line">    leftPos := n*<span class="number">2</span></span><br><span class="line">    left := (*heap)[n*<span class="number">2</span> - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> n*<span class="number">2</span> &lt; <span class="built_in">len</span>(*heap) &#123;</span><br><span class="line">        right := (*heap)[n*<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> right &lt; left &#123;</span><br><span class="line">            left = right</span><br><span class="line">            leftPos =  n*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left &lt; val &#123;</span><br><span class="line">        (*heap)[leftPos - <span class="number">1</span>],(*heap)[n<span class="number">-1</span>] = (*heap)[n<span class="number">-1</span>],(*heap)[leftPos - <span class="number">1</span>]</span><br><span class="line">        update(heap, leftPos)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>分治，其实就是快排，只是说如果某次快排的基准点刚好是k，就不用再排下去了，平均时间复杂度O(n)，最坏情况O(n^n)，空间复杂度O(1)（因为用的是快排原地交换的逻辑）<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthLargest</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> quickSort <span class="function"><span class="keyword">func</span><span class="params">(left,right <span class="keyword">int</span>)</span><span class="title">int</span></span></span><br><span class="line">    quickSort = <span class="function"><span class="keyword">func</span><span class="params">(left,right <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> left == right &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        &#125;</span><br><span class="line">        base := nums[left]</span><br><span class="line">        basePost := left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i:= left+<span class="number">1</span>; i&lt;= right; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; base &#123;</span><br><span class="line">                nums[i],nums[basePost] = nums[basePost], nums[i]</span><br><span class="line">                basePost++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left],nums[basePost<span class="number">-1</span>] = nums[basePost<span class="number">-1</span>], nums[left]</span><br><span class="line">        <span class="keyword">if</span> basePost == k &#123;</span><br><span class="line">            <span class="keyword">return</span> base</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> basePost &lt; k &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSort(basePost, right)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSort(left, basePost<span class="number">-2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(<span class="number">0</span>,<span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h2><p>题目：<a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">https://leetcode.com/problems/find-median-from-data-stream/</a></p>
<p>解法：</p>
<ol>
<li>错误解法：二分法，能做但是时间复杂度太高</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MedianFinder <span class="keyword">struct</span> &#123;</span><br><span class="line">    val []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MedianFinder</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MedianFinder&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span> <span class="title">AddNum</span><span class="params">(num <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.val) == <span class="number">0</span> &#123;</span><br><span class="line">        this.val = <span class="built_in">append</span>(this.val, num)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    left := <span class="number">0</span> </span><br><span class="line">    right := <span class="built_in">len</span>(this.val) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> pos <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">            <span class="keyword">if</span> this.val[left] &gt;=num &#123;</span><br><span class="line">                pos = left</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos = left+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid := (left + right )/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> this.val[mid] &lt;= num &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    rightNums := <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;,this.val[pos:]...)</span><br><span class="line">    this.val = <span class="built_in">append</span>(this.val[:pos],num)</span><br><span class="line">    this.val = <span class="built_in">append</span>(this.val, rightNums...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span> <span class="title">FindMedian</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    ll := <span class="built_in">len</span>(this.val)</span><br><span class="line">    <span class="keyword">if</span> ll % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(this.val[ll/<span class="number">2</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float64</span>(this.val[ll/<span class="number">2</span> - <span class="number">1</span>]) + <span class="keyword">float64</span>(this.val[ll/<span class="number">2</span>])) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用一个最大堆和一个最小堆来维护中位数。很可以理解的解法但是用go得再手写一遍最大堆和最小堆好累啊（以后有心情再说）（前面已经写过一次最小堆了嗯）</li>
<li>用红黑树，嗯红黑树。。。</li>
</ol>
<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>题目：<a href="https://leetcode.com/problems/maximum-subarray/submissions/1120161253/、" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/submissions/1120161253/、</a></p>
<p>解法：</p>
<ol>
<li><p>双指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left,right <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> max,now <span class="keyword">int</span></span><br><span class="line">    ll := <span class="built_in">len</span>(nums)</span><br><span class="line">    now = nums[<span class="number">0</span>]</span><br><span class="line">    max = nums[<span class="number">0</span>]</span><br><span class="line">    right = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> right &lt; ll &#123;</span><br><span class="line">            <span class="keyword">if</span> now &lt; <span class="number">0</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> ;left&lt;right; left++ &#123;</span><br><span class="line">                    now -= nums[left]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            now += nums[right]</span><br><span class="line">            <span class="keyword">if</span> now &gt; max &#123;</span><br><span class="line">                max = now</span><br><span class="line">            &#125;</span><br><span class="line">            right++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dp，不过我偷懒写了个没有优化空间的方案，其实空间复杂度可以到O(1)<br>$$<br>sum(i) = max(f(i),sum(i-1)+f(i))<br>$$<br>$$<br>dp(i) = max(dp(i-1), sum(i))<br>$$</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ll := <span class="built_in">len</span>(nums)</span><br><span class="line">    merge := <span class="built_in">make</span>([]<span class="keyword">int</span>,ll)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>,ll)</span><br><span class="line">    merge[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;ll;i++ &#123;</span><br><span class="line">        merge[i]=merge[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">        <span class="keyword">if</span> merge[i]&lt;nums[i] &#123;</span><br><span class="line">            merge[i] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> merge[i] &gt; dp[i] &#123;</span><br><span class="line">            dp[i] = merge[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[ll<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>贪心，其实和双指针很相似但是更直接一点（也有效），只要当前和是小于0的就丢弃</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    curSum := nums[<span class="number">0</span>]</span><br><span class="line">    maxVal := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> curSum &lt; <span class="number">0</span> &#123;</span><br><span class="line">            curSum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        curSum += nums[i]</span><br><span class="line">        <span class="keyword">if</span> curSum &gt; maxVal &#123;</span><br><span class="line">            maxVal = curSum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxVal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="1到n整数中1出现的次数"><a href="#1到n整数中1出现的次数" class="headerlink" title="1到n整数中1出现的次数"></a>1到n整数中1出现的次数</h2><p>题目：<a href="https://leetcode.com/problems/number-of-digit-one/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-digit-one/</a></p>
<p>一开始没有思路后来看了一眼题解，计算每一位出现的次数，豁然开朗</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countDigitOne</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    cur := <span class="number">1</span></span><br><span class="line">    raw := n</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        last := n%<span class="number">10</span></span><br><span class="line">        n = n/<span class="number">10</span></span><br><span class="line">        cnt += n * cur</span><br><span class="line">        <span class="keyword">if</span> last &gt; <span class="number">1</span> &#123;</span><br><span class="line">            cnt += cur</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> last == <span class="number">1</span> &#123;</span><br><span class="line">            cnt += (raw%cur) + <span class="number">1</span></span><br><span class="line">        &#125; </span><br><span class="line">        cur *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="把数组排成最大的数"><a href="#把数组排成最大的数" class="headerlink" title="把数组排成最大的数"></a>把数组排成最大的数</h2><p>题目：<a href="https://leetcode.com/problems/largest-number/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-number/</a></p>
<p>题解：</p>
<ol>
<li>一开始想的是遍历两次，按照int(a+b)&gt;int(b+a)的顺序排起来<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> k,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        cur := strconv.Itoa(num)</span><br><span class="line">        <span class="keyword">for</span> i,val := <span class="keyword">range</span> res &#123;</span><br><span class="line">            <span class="keyword">if</span> compare(cur,val) &#123;</span><br><span class="line">                last := <span class="built_in">append</span>([]<span class="keyword">string</span>&#123;&#125;, res[i:]...)</span><br><span class="line">                res = <span class="built_in">append</span>(res[:i], cur)</span><br><span class="line">                res = <span class="built_in">append</span>(res, last...)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) == k &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res,cur)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> res[<span class="number">0</span>] == <span class="string">"0"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings.Join(res,<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(a,b <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    left,_ := strconv.Atoi(a+b)</span><br><span class="line">    right,_:= strconv.Atoi(b+a)</span><br><span class="line">    <span class="keyword">return</span> left &gt; right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>然后发现自己只是写了个很拙劣的插入排序，其实核心是compare函数，这题本质是个排序，对所有算法都适用的</p>
<ol start="2">
<li>用go提供的slice排序来处理，好像是个快排，待排序数组为s:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort.Slice(s,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span><span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在这题的逻辑就是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort.Slice(s,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span><span class="title">bool</span></span> &#123;</span><br><span class="line">    left,_ := strconv.Atoi(s[i]+s[j])</span><br><span class="line">    right,_:= strconv.Atoi(s[j]+s[i])</span><br><span class="line">    <span class="keyword">return</span> left &gt; right</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>简化一点其实可以直接用字典排序：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sort.Slice(s,<span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span><span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s[i][<span class="number">0</span>] == s[j][<span class="number">0</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> s[i] + s[j] &gt; s[j] + s[i]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s[i] &gt; s[j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>最后：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, strconv.Itoa(num))</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(res, <span class="function"><span class="keyword">func</span><span class="params">(i,j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> res[i][<span class="number">0</span>] == res[j][<span class="number">0</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> res[i] + res[j] &gt; res[j] + res[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res[i] &gt; res[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> res[<span class="number">0</span>] == <span class="string">"0"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings.Join(res,<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="把数字翻译成字符串个数"><a href="#把数字翻译成字符串个数" class="headerlink" title="把数字翻译成字符串个数"></a>把数字翻译成字符串个数</h2><p>题目：<a href="https://leetcode.com/problems/decode-ways/submissions/1122667338/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china" target="_blank" rel="noopener">https://leetcode.com/problems/decode-ways/submissions/1122667338/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china</a></p>
<p>怎么看都是一道dp题，不过关于0和&gt;27的场景有很多判断条件，一定要理清楚再写</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDecodings</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'0'</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    before := <span class="number">1</span></span><br><span class="line">    now := <span class="number">1</span></span><br><span class="line">    ll := <span class="built_in">len</span>(s)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">1</span>; i&lt;ll; i++ &#123;</span><br><span class="line">        tmp := start</span><br><span class="line">        start = before</span><br><span class="line">        before = now</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">'0'</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i<span class="number">-1</span>]  == <span class="string">'0'</span> || s[i<span class="number">-1</span>:i+<span class="number">1</span>] &gt; <span class="string">"27"</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                now = start</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">'0'</span> &#123;</span><br><span class="line">            now = tmp</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> s[i<span class="number">-1</span>:i+<span class="number">1</span>] &lt; <span class="string">"27"</span> &#123;</span><br><span class="line">            now += start</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            now = before</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> now</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径和"><a href="#最短路径和" class="headerlink" title="最短路径和"></a>最短路径和</h2><p>题目：<a href="https://leetcode.com/problems/minimum-path-sum/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-path-sum/submissions/</a></p>
<p>熟悉的dp again，应该说是最经典的dp之一<br>我这里偷了判断的懒，加了个初始化，其实用 if i == 0 j == 0也没啥问题<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    xlen := <span class="built_in">len</span>(grid)</span><br><span class="line">    ylen := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    beforeRow := <span class="built_in">make</span>([]<span class="keyword">int</span>, ylen+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> j,row := <span class="keyword">range</span> grid[<span class="number">0</span>] &#123;</span><br><span class="line">        beforeRow[j+<span class="number">1</span>] = beforeRow[j]+row</span><br><span class="line">    &#125;</span><br><span class="line">    beforeRow[<span class="number">0</span>] = beforeRow[ylen]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;xlen; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j,val := <span class="keyword">range</span> grid[i] &#123;</span><br><span class="line">            beforeRow[j+<span class="number">1</span>] = min(beforeRow[j], beforeRow[j+<span class="number">1</span>]) + val </span><br><span class="line">        &#125;</span><br><span class="line">        beforeRow[<span class="number">0</span>] = beforeRow[ylen]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beforeRow[ylen]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="无重复字符最短字串"><a href="#无重复字符最短字串" class="headerlink" title="无重复字符最短字串"></a>无重复字符最短字串</h2><p>题目：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p>
<p>滑动窗口嘛，常用办法是双指针，右指针代表当前字母，左指针代表子字符串开头，两个循环</p>
<p>这里用空间换了点时间，用map存当前字符串的最近一个位置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    posMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>, <span class="number">26</span>)</span><br><span class="line">    <span class="keyword">var</span> max,preLen <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i,d := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> pos,ok := posMap[d]; ok &amp;&amp; i-preLen &lt;= pos&#123;</span><br><span class="line">            preLen = i - pos</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            preLen++</span><br><span class="line">            <span class="keyword">if</span> max &lt; preLen &#123;</span><br><span class="line">                max = preLen</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        posMap[d] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><p>题目：<a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/ugly-number-ii/</a></p>
<p>方案</p>
<ol>
<li>不想写，但是可以堆排+hash去重</li>
<li><blockquote>
<blockquote>
<p>当 2≤i≤n2 \le i \le n2≤i≤n 时，令dp[i]=min⁡(dp[p2]×2,dp[p3]×3,dp[p5]×5)\textit{dp}[i]=\min(\textit{dp}[p_2] \times 2, \textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5)dp[i]=min(dp[p2]×2,dp[p3]×3,dp[p5]×5)，然后分别比较 dp[i]\textit{dp}[i]dp[i] 和 dp[p2]×2,dp[p3]×3,dp[p5]×5\textit{dp}[p_2] \times 2,\textit{dp}[p_3] \times 3,\textit{dp}[p_5] \times 5dp[p2]×2,dp[p3]×3,dp[p5]×5 是否相等，如果相等则将对应的指针加 111。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nthUglyNumber</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p2,p3,p5 <span class="keyword">int</span></span><br><span class="line">    uglyList := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    uglyList[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> val <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            v2 := uglyList[p2] * <span class="number">2</span></span><br><span class="line">            v3 := uglyList[p3] * <span class="number">3</span></span><br><span class="line">            v5 := uglyList[p5] * <span class="number">5</span></span><br><span class="line">            <span class="keyword">if</span> v2 &lt; v3 &#123;</span><br><span class="line">                p = &amp;p2</span><br><span class="line">                val = v2</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = &amp;p3</span><br><span class="line">                val = v3</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> val &gt; v5 &#123;</span><br><span class="line">                p = &amp;p5</span><br><span class="line">                val = v5</span><br><span class="line">            &#125;</span><br><span class="line">            *p += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> val != uglyList[i<span class="number">-1</span>] &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        uglyList[i] = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uglyList[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="字符串中第一个只出现一次的字符"><a href="#字符串中第一个只出现一次的字符" class="headerlink" title="字符串中第一个只出现一次的字符"></a>字符串中第一个只出现一次的字符</h2><p>题目：<a href="https://leetcode.com/problems/first-unique-character-in-a-string/description/" target="_blank" rel="noopener">https://leetcode.com/problems/first-unique-character-in-a-string/description/</a></p>
<p>解法：</p>
<ol>
<li>可以用hash保存次数，再遍历一次返回次数大于一的</li>
<li>用hash改成用26字母数组，保存是否为单数/是单数的位置，空间复杂度O(1)，时间复杂度O(n)</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">26</span>)</span><br><span class="line">    ll := <span class="built_in">len</span>(s)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i,val := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> count[val-<span class="string">'a'</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            count[val-<span class="string">'a'</span>] = ll</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count[val-<span class="string">'a'</span>] = i+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    min := ll</span><br><span class="line">    <span class="keyword">for</span> _,val := <span class="keyword">range</span> count &#123;</span><br><span class="line">        <span class="keyword">if</span> val != ll &amp;&amp; val != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> min &gt; val &#123;</span><br><span class="line">                min = val</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> min == ll &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min<span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h2><p>题目：<a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&amp;&amp;tqId=11207&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&amp;&amp;tqId=11207&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p>解法：</p>
<ol>
<li><p>干了一件很神奇的事情，搞了两个数组，一模一样大，第一个存第一次出现的byte，第二个存第二次出现的byte，虽然性能肯定不是最好的但是还挺好玩</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pops []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> pops2 []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(ch <span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    ll := <span class="built_in">len</span>(pops)</span><br><span class="line">    <span class="keyword">var</span> flag <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;ll; i++ &#123;</span><br><span class="line">        val := pops[i]</span><br><span class="line">        <span class="keyword">if</span> val == ch&#123; </span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">            pops2[i] = ch </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !flag &#123;</span><br><span class="line">        pops = <span class="built_in">append</span>(pops, ch)</span><br><span class="line">        pops2 = <span class="built_in">append</span>(pops2, <span class="keyword">byte</span>(<span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">    ll := <span class="built_in">len</span>(pops)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;ll; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> pops[i] != pops2[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> pops[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'#'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个优化是用map保存地址，在插入的时候就不需要遍历，节约时间。第二个是获取的时候遍历数组而不是map</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pops []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> posMap = <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(ch <span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _,ok := posMap[ch]; !ok &#123;</span><br><span class="line">        posMap[ch] = <span class="built_in">len</span>(pops)</span><br><span class="line">        pops = <span class="built_in">append</span>(pops, ch)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        posMap[ch] = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _,b := <span class="keyword">range</span> pops &#123;</span><br><span class="line">        <span class="keyword">if</span> posMap[b] != <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'#'</span>   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p>题目：<a href="https://leetcode.com/problems/reverse-pairs/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-pairs/</a><br>理论上也是老朋友了但是不影响写起来好陌生<br>用的是分治的思路，先算出每个子数组里面的逆序对数，同时排序，因为归并的求逆序对数和排序需要两次O(n)，最后的时间复杂度就是O(nlogn)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePairs</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span>  mergeSort <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span></span><br><span class="line">    mergeSort = <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">        ll := <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> ll == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        &#125;</span><br><span class="line">        mid := ll/<span class="number">2</span></span><br><span class="line">        rightl := ll - mid</span><br><span class="line">        left := mergeSort(nums[:mid])</span><br><span class="line">        right := mergeSort(nums[mid:])</span><br><span class="line">        res := <span class="built_in">make</span>([]<span class="keyword">int</span>, ll)</span><br><span class="line">        <span class="keyword">var</span> righti,lefti <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span>  &#123;</span><br><span class="line">            <span class="keyword">if</span> lefti &gt;= mid || righti &gt;= rightl &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> left[lefti] &gt; right[righti] * <span class="number">2</span> &#123;</span><br><span class="line">                num += mid - lefti</span><br><span class="line">                righti++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lefti++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lefti = <span class="number">0</span></span><br><span class="line">        righti = <span class="number">0</span></span><br><span class="line">        i := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> lefti &gt;= mid || righti &gt;= rightl &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> left[lefti] &gt; right[righti] &#123;</span><br><span class="line">                res[i] = right[righti]</span><br><span class="line">                righti++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = left[lefti]</span><br><span class="line">                lefti++</span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lefti &lt; mid &#123;</span><br><span class="line">            <span class="keyword">for</span> ; lefti &lt;mid; lefti++ &#123;</span><br><span class="line">                res[i] = left[lefti]</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> righti &lt; rightl &#123;</span><br><span class="line">            <span class="keyword">for</span> ; righti &lt;rightl; righti++ &#123;</span><br><span class="line">                res[i] = right[righti]</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    mergeSort(nums)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>题目：<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-linked-lists/</a><br>解法1: 用哈希记录已经访问节点<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    seenHash := <span class="keyword">map</span>[*ListNode]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line">    aHead := headA</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> aHead != <span class="literal">nil</span> &#123;</span><br><span class="line">            seenHash[aHead] = <span class="literal">true</span></span><br><span class="line">            aHead = aHead.Next</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> headB == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _,ok := seenHash[headB]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> headB</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            headB = headB.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解法2: 核心思路是消除长度差，不过我的脑回路比较简单，就是先算出两个链表的长度差，再抹平，再遍历<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    aHead := headA</span><br><span class="line">    bHead := headB</span><br><span class="line">    <span class="keyword">var</span> aTimes,bTimes <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        aTimes++</span><br><span class="line">        <span class="keyword">if</span> aHead.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        aHead = aHead.Next</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        bTimes++</span><br><span class="line">        <span class="keyword">if</span> bHead.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        bHead = bHead.Next</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> aHead != bHead &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> aTimes &gt; bTimes &#123;</span><br><span class="line">        t := aTimes - bTimes</span><br><span class="line">        left = bTimes</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t;i++ &#123;</span><br><span class="line">            headA = headA.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t := bTimes - aTimes</span><br><span class="line">        left = bTimes</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;t;i++ &#123;</span><br><span class="line">            headB = headB.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;left; i++&#123;</span><br><span class="line">        <span class="keyword">if</span> headA == headB &#123;</span><br><span class="line">            <span class="keyword">return</span> headA</span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA.Next</span><br><span class="line">        headB = headB.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解法3:本质还是抹平长度差，但是解法讨巧很多，当A结尾后指向B，当B结尾后指向A，相当于两个链表各循环了一次，天然抹平了长度差<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    aHead := headA</span><br><span class="line">    bHead := headB</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> aHead == bHead &#123;</span><br><span class="line">            <span class="keyword">return</span> aHead</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> aHead == <span class="literal">nil</span> &#123;</span><br><span class="line">            aHead = headB</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            aHead = aHead.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bHead == <span class="literal">nil</span> &#123;</span><br><span class="line">            bHead = headA</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bHead = bHead.Next</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/12/08/刷题碎碎念一：环形链表快慢指针之为什么/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/08/刷题碎碎念一：环形链表快慢指针之为什么/" itemprop="url">
                  刷题碎碎念一：环形链表快慢指针之为什么
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-12-08 16:56:23 / Modified: 17:29:27" itemprop="dateCreated datePublished" datetime="2023-12-08T16:56:23+08:00">2023-12-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用快慢指针找环形链表是个非常非常非常常见的题型，之前在leetcode <a href="https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/" target="_blank" rel="noopener">find duplicate number</a> 见到了环形链表的解法，就顺手算了一下，算完给自己留个纪念（毕竟这可能是第三次算这东西了。。。）（每次都像是什么崭新的知识点）</p>
<h2 id="快慢指针找环形链表解法"><a href="#快慢指针找环形链表解法" class="headerlink" title="快慢指针找环形链表解法"></a>快慢指针找环形链表解法</h2><p>过分经典在这里放个链接顺便随便说说吧：<a href="https://leetcode.cn/problems/c32eOV/solutions/1037744/lian-biao-zhong-huan-de-ru-kou-jie-dian-vvofe/" target="_blank" rel="noopener">https://leetcode.cn/problems/c32eOV/solutions/1037744/lian-biao-zhong-huan-de-ru-kou-jie-dian-vvofe/</a></p>
<p>简单来说就是有一个快指针<code>fast</code>和一个慢指针<code>slow</code>，快指针每次往前走两步，慢指针每次往前走一步，如果两个指针最终相遇，那就说明这个链表是个环形链表</p>
<p><strong>那怎么找入环口呢?</strong></p>
<p>在两个节点相遇之后，掏出一个新的指针 <code>ptr</code> 指向链表头部，然后和 <code>slow</code> 每次往前走一步，这两个指针就会在入环点相遇</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>感觉真的算了很多次了但是每次都记不住QAQ</p>
<p>来随便写个个链表：</p>
<p>HEAD–B–…–C–Enter–D–…–Enter</p>
<p>假设：</p>
<ul>
<li>从head到Enter（不包含）一共<code>a</code>步</li>
<li>环内一共 <code>b</code> 节点（包含enter）</li>
<li>环内相遇时包含Enter和相遇节点一共距离enter <code>x</code> 节点</li>
<li>$\alpha$ 和 $\beta$ 是模数，任意</li>
</ul>
<p>那么当fast和slow相遇时，可以写个公式：</p>
<p>$a + x + \alpha b = 2(a+x)$</p>
<p>所以也就可以得知： 只要有一个 $x &gt;= 1 \&amp;\&amp; x &lt;= b$ 时满足：当 $a + x = \alpha b$ 就可以</p>
<p>那就很简单了，$x=b - (a \bmod b)$</p>
<p>再来看一下找入环口这件事情的公式，一共走了a+1步：</p>
<p>$a + 1 + x = \beta b + 1$</p>
<p>看 $a + x = \alpha b$，这个事情就是很自然而然的了对不对</p>
<p>好了欢乐结束了希望不要再忘了</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/04/26/redis学习笔记五：其他独立功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/26/redis学习笔记五：其他独立功能/" itemprop="url">
                  redis学习笔记五：其他独立功能
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-04-26 21:09:13 / Modified: 21:14:35" itemprop="dateCreated datePublished" datetime="2023-04-26T21:09:13+08:00">2023-04-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>开启事务：MULTI命令切换至事务状态</p>
<p>非事务状态：来一个get/set命令，立刻执行</p>
<p>事务状态：</p>
<ul>
<li>如果客户端发送的命令为 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令的其中一个， 那么服务器立即执行这个命令</li>
<li>如果不是这四个命令，扔进事务队列</li>
</ul>
<h3 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h3><p>每个 Redis 客户端都有自己的事务状态， 这个事务状态保存在客户端状态的 <code>mstate</code> 属性里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisClient &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 事务状态</span><br><span class="line">    multiState mstate;      /* MULTI/EXEC state */</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>
<p>事务状态包含一个事务队列， 以及一个已入队命令的计数器 （也可以说是事务队列的长度）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct multiState &#123;</span><br><span class="line"></span><br><span class="line">    // 事务队列，FIFO 顺序</span><br><span class="line">    multiCmd *commands;</span><br><span class="line"></span><br><span class="line">    // 已入队命令计数</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure>
<h3 id="执行EXEC"><a href="#执行EXEC" class="headerlink" title="执行EXEC"></a>执行EXEC</h3><blockquote>
<p>当一个处于事务状态的客户端向服务器发送 EXEC 命令时， 这个 EXEC 命令将立即被服务器执行： 服务器会遍历这个客户端的事务队列， 执行队列中保存的所有命令， 最后将执行命令所得的结果全部返回给客户端。</p>
</blockquote>
<p>执行失败：</p>
<p>当事务中的某个命令执行失败的时候，redis不会返回报错也不会回滚，而是会执行后面的命令</p>
<h3 id="监听Watch"><a href="#监听Watch" class="headerlink" title="监听Watch"></a>监听Watch</h3><h4 id="cas和aba问题"><a href="#cas和aba问题" class="headerlink" title="cas和aba问题"></a>cas和aba问题</h4><p>背景：cas和aba问题</p>
<p>cas：compare and swap，为了解决并发场景下同时访问同一个共享变量时导致的冲突问题，比如a在改变量env的时候b正好在改它</p>
<p>当然了也可以用锁，如果几个线程都是读线程，挨个获取锁就消耗了大量的时间和block的线程资源，所以锁也被称为悲观锁，就是假设了一种悲观场景，每次访问共享变量都会遇到冲突</p>
<p>cas就是很常用的乐观锁机制，它其实在代码逻辑上并没有上锁并且乐观的认为大部分人来访问它就是为了读而已，遇到冲突是很少的场景</p>
<blockquote>
<p>CAS 的思想很简单：三个参数，一个当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false</p>
</blockquote>
<p>在这里抄一点来自java的cas使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = <span class="keyword">this</span>.getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，利用cas来实现原子操作而不是真的搞个自旋锁，去比较获取的值和预期是否一致，一致就认为没有其他线程在改动变量，当然了cas底层的compare和swap操作本身还是可以用自旋锁去实现的</p>
<p>当然了就想在多读少写的情况下用自旋锁太耗时一样，如果是多写少读的场景就会有很多线程陷入无限循环，会给cpu带来大量的开销</p>
<p>aba问题：当另一个线程先把变量env=a改成env=b，又改成了env=a，而改动因为执行速度很快恰好没有被捕捉到，那还是会出现多个线程同时改一个变量的场景</p>
<p>当然为了解决aba问题不同的系统用了不同的改进方法，比如java就加了版本号的概念，每次修改也会把版本号+1</p>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>再回到redis，redis事务中watch的执行就是用了类似cas的乐观锁机制，不过它不是在执行的时候去compare，而是，肤浅的理解就是从watch指令开始就盯住对应的变量，一旦变量发生改动就通知客户端，取消事务，也就避免了aba问题</p>
<p>注意：在redis中只要exec开始执行就不会再有回滚之类的任何操作，所以watch的校验都是在exec之前的，exec执行后就会取消对所有键的监控，所以watch的意义是阻止执行</p>
<p>给个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH name</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>
<h2 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h2><p>不想看用到再说</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/04/13/redis学习笔记四：多机数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/13/redis学习笔记四：多机数据库/" itemprop="url">
                  redis学习笔记四：多机数据库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-04-13 18:08:10 / Modified: 19:31:08" itemprop="dateCreated datePublished" datetime="2023-04-13T18:08:10+08:00">2023-04-13</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ol>
<li>从服务器发送sync请求到主服务器</li>
<li>主服务器生成RDB，并把之后的写命令都扔进一个缓冲区</li>
<li>主服务器把RDB发给从服务器，从服务器初始化</li>
<li>主服务器把缓冲区命令发给从服务器，从服务器执行，使得两边数据一致</li>
</ol>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>同步是在从服务器创建的时候从主服务器同步数据，命令传播是在主服务器的数据变动的时候把写命令同步给从服务器的行为</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>断线导致丢失数据的情况要怎么办？</p>
<p>– 同步：重同步</p>
<p>完整重同步和同步是一样，就是用在初始化同步数据</p>
<p>部分重同步则是用来处理断线后重复制的情况</p>
<blockquote>
<p>部分重同步用于处理断线后重复制的情况：当从服务器在断线后重新连接到主服务器时，如果条件允许，主服务器可以将断线后这一段时间执行的血命令发送给从服务器，从服务器只接收并执行这些写命令，就可以将从服务器数据库的状态更新至主服务器当前的状态。</p>
</blockquote>
<ol>
<li>偏移量：主服务器和从服务器分别维护一个复制偏移量，主服务器发N个消息就给自己的偏移量+N，从服务器收到N个就把自己的偏移量+N，这样一对就知道少了啥了</li>
<li>复制积压缓冲区：一块大小固定的缓冲区，主服务器会把自己收到的写命令和对应的offset都存在里面，对了一下偏移量，如果对应偏移量的数据还在缓冲区就直接把后面的指令给从服务器，不在缓冲区的话就执行完整重同步</li>
<li>服务器运行ID：从服务器在初始化复制的时候会把对应的主服务器id存下来，从服务器断线重启之后向主服务器发请求，如果id和主服务器id是同一个，就执行部分重同步，不一样（不大理解为啥会不一样）就完整重同步</li>
</ol>
<p>– 命令传播：心跳检测</p>
<p>在命令传播阶段，从服务器会每秒给主服务器发一个当前offset</p>
<ol>
<li>监测连接状态，一秒以后没收到连接可能就有问题了</li>
<li>如果连接正常的从服务器少于一个数量或者延迟很大的时候，主服务器可以拒接写入</li>
<li>offset也可以用来监测是不是丢命令了</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点很明显，就是主从实现读写分离嘛，减少了主服务器的压力</p>
<p>缺点也很明显，主服务器挂了就没了，没有任何的容错能力，而且也没办法支持扩容之类的操作</p>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>唉又是那个毛病，开头能不能先介绍一下sentinel是啥</p>
<p>首先假定（好像不是假定）redis的集群模式是master-slave（好像确实就是），如果master挂了，需要再选一个master节点出来，并且把之前master的slave都转移到新的master头上，这个系统就叫做哨兵系统(sentinel)</p>
<p>当然了同时我们就可以利用sentinel系统监控各个节点的特征，获取节点信息配置监控告警等</p>
<p>受不了了怎么还看到了raft，感觉自己在看hdfs和zk，sentinel集群和zk集群感觉其实真的差不多</p>
<p>TBD：</p>
<p>有空自己开一下sentinel模式试试看</p>
<p>简单来说就是sentinel系统本身就是一个节点，但是这个节点和普通redis节点不一样的是它开启了sentinel模式，同时command表也就不支持set之类的操作，而是pong这样的sentinel模式需要的命令</p>
<h3 id="启动连接"><a href="#启动连接" class="headerlink" title="启动连接"></a>启动连接</h3><p>sentinel启动的最后一步是向被监视的主服务器建立网络连接，sentinel会建立两种异步网络连接：</p>
<blockquote>
<ul>
<li>一个是命令连接， 这个连接专门用于向主服务器发送命令， 并接收命令回复。</li>
<li>另一个是订阅连接， 这个连接专门用于订阅主服务器的 <code>__sentinel__:hello</code> 频道。</li>
</ul>
</blockquote>
<p>关于订阅连接究竟是为什么要出现，各种地方的解释不一样，有的文档（包括这本Redis设计与实现）说订阅连接是为了防止丢失信息，因为订阅连接是个长连接，所以即使命令连接的返回数据丢了，也可以从订阅连接里收到。另一个说法是订阅连接可以帮助sentinel发现其他sentinel，从而建立<strong>Sentinel集群</strong>，姑且我们认为两种都有吧</p>
<h3 id="获取slave节点"><a href="#获取slave节点" class="headerlink" title="获取slave节点"></a>获取slave节点</h3><p> Sentinel 以每十秒一次的频率向被监视的主服务器发送 INFO 命令，INFO命令会返回改主服务器下从服务器的信息。获取到从服务器的信息后，sentinel就可以向从服务器建立命令连接和订阅连接</p>
<h3 id="建立Sentinel集群"><a href="#建立Sentinel集群" class="headerlink" title="建立Sentinel集群"></a>建立Sentinel集群</h3><p>默认情况下，Sentinel每2s一次，向所有被监视的主服务器和从服务器所订阅的<em>sentinel</em>:hello频道上发送消息，消息中会携带Sentinel自身的信息和主服务器的信息。这个信息先叫他频道消息。</p>
<p>因为每个sentinel都会向每个监视的服务器发频道消息，所以对于监视同一个服务器的多个sentinel来说，sentinel可以通过频道消息感知到其他sentinel的存在。</p>
<p><strong>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接</strong>（但是不创建订阅连接）</p>
<p><img src="/../images/redis/sentinel集群.png" alt></p>
<p>感想就是如果还想研究细节可以去再学一遍zk</p>
<h3 id="发现下线"><a href="#发现下线" class="headerlink" title="发现下线"></a>发现下线</h3><p>主观下线：</p>
<blockquote>
<p>默认情况下，Sentinel每秒一次向所有与它建立了命令连接的实例(包括主服务器、从服务器和其他Sentinel)发送PING命令，并根据回复判断实例是否在线。如果在Sentinel配置文件中的down-after-milliseconds毫秒内，连接向Sentinel返回无效回复，那么Sentinel就会认为该实例<strong>主观下线(SDown)</strong>。</p>
</blockquote>
<p>sentinel认为这个服务器主观下线之后，就会去检查它是不是真的下线了，也就是客观下线：</p>
<blockquote>
<p>为了确认是否真的下线，这个Sentinel会向同时监控这个主服务器的所有其他Sentinel发送查询命令，判断它们是否也任务主服务器下线(包括主观下线和客观下线)。如果达到Sentinel配置中的quorum数量的Sentinel实例都判断主服务器为主观下线，则该主服务器就会被判定为<strong>客观下线</strong>。</p>
</blockquote>
<h3 id="leader-sentinel选举"><a href="#leader-sentinel选举" class="headerlink" title="leader sentinel选举"></a>leader sentinel选举</h3><p>看到了吗熟悉的raft</p>
<p>说起来在这里放个raft的论文网址：<a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14" target="_blank" rel="noopener">https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14</a> 以后方便找</p>
<p>稍微简单解释一下，就是判定服务器为客观下线的sentinel节点可以发起选举，选举拿到半数以上赞成票并且超过一个设定阈值（<strong>quorum 值</strong>这个东西看上去像redis原创的？）就能当leader</p>
<p>至于具体的投票限制平票方案等等还是去看raft吧，反正就是选了个leader sentinel出来</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><ol>
<li>选新master。当然是有一些条件的<ol>
<li>过滤掉下线节点，过滤掉最近5s没有回复sentinel info的节点</li>
<li>选conf配置里设定优先级高的节点</li>
<li>优先级一样的话选复制偏移量最大的</li>
</ol>
</li>
<li>将所有从服务器改为复制新的主服务器。</li>
<li>将已下线的主服务器设置为新的主服务器的从服务器。</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>master-slave的运行本身基于主从复制模式，所以该有的还是有</li>
<li>master挂掉就可以自动切换</li>
</ol>
<p>缺点：</p>
<ol>
<li>扩容还是不支持，容量还是依赖master节点机器配置</li>
<li>不知道算不算缺点的缺点，运行sentinel集群需要消耗额外的资源</li>
</ol>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>也来简单介绍一下，集群模式和sentinel模式是两种不一样的模式，集群模式的逻辑就是去中心化，每个节点都和集群内其他节点有连接，集群内部也可以设置主从，比如六个节点的话可以设置三主三从，主挂了从将自动变成主节点，但是和前面的读写分离不大一样，这里从节点主要是拿来做热备的，因为分布式存储本身就解决了吞吐量的问题（个人看书的理解</p>
<p>同时集群和前面两种模式不一样的是，每个主节点保存的东西都是不一样的，也就是终于转变为了分布式存储（可喜可贺）</p>
<p>集群本身的启动，集群的搭建和主从设置都是要在启动的时候通过配置实现的。    </p>
<p>连接各个节点的工作可以使用 CLUSTER MEET 命令来完成， 该命令的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>我猜哈我猜，在配置里配好集群节点之后，每个节点启动的时候会执行cluster meet，将对应的节点加到自己所属的集群中</p>
<h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>一个节点就是一个运行在集群模式下的 Redis 服务器， Redis 服务器在启动时会根据 <code>cluster-enabled</code> 配置选项的是否为 <code>yes</code> 来决定是否开启服务器的集群模式。</p>
<p>集群模式下其他都是都是正常运行，同时<code>serverCon</code>会调用<code>clusterCron</code> 函数来执行在集群模式下需要执行的常规操作</p>
<p>集群相关的信息会被保存在 <code>cluster.h/clusterNode</code> 结构， <code>cluster.h/clusterLink</code> 结构， 以及 <code>cluster.h/clusterState</code> 结构里面</p>
<h4 id="clusterNode"><a href="#clusterNode" class="headerlink" title="clusterNode"></a>clusterNode</h4><p>每个节点都会使用一个 <code>clusterNode</code> 结构来记录自己的状态， 并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的<code>clusterNode</code> 结构， 以此来记录其他节点的状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的名字，由 40 个十六进制字符组成</span></span><br><span class="line">    <span class="comment">// 例如 68eef66df23420a5862208ef5b1a7005b806f2ff</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点标识</span></span><br><span class="line">    <span class="comment">// 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），</span></span><br><span class="line">    <span class="comment">// 以及节点目前所处的状态（比如在线或者下线）。</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的 IP 地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的端口号</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="clusterLink"><a href="#clusterLink" class="headerlink" title="clusterLink"></a>clusterLink</h4><p>clusterLink保存的是连接到节点所需要的连接信息，还挺明显的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出缓冲区，保存着等待发送给其他节点的消息（message）。</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与这个连接相关联的节点，如果没有的话就为 NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure>
<h4 id="clusterState"><a href="#clusterState" class="headerlink" title="clusterState"></a>clusterState</h4><p>最后， 每个节点都保存着一个 <code>clusterState</code> 结构， 这个结构记录了在当前节点的视角下， 集群目前所处的状态 —— 比如集群是在线还是下线， 集群包含多少个节点， 集群当前的配置纪元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的状态：是在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群中至少处理着一个槽的节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群节点名单（包括 myself 节点）</span></span><br><span class="line">    <span class="comment">// 字典的键为节点的名字，字典的值为节点对应的 clusterNode 结构</span></span><br><span class="line">    dict *nodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>redis集群引入了哈希槽（hash slot）的概念，Redis 集群有16384 个哈希槽，每个节点负责一部分hash槽，每个key通过对16384取mod来决定自己的数据放在哪个hash槽，这样在节点增加或删除的时候，只要通过改变一部分hash槽的归属就可以实现</p>
<h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p>作为一个去中心化的东西，自然没有一个路由器专门接收请求根据slot扔给对应的节点，无论Redis 的客户端访问集群中的哪个节点都可以路由到对应的节点上</p>
<ol>
<li>客户端算了一下觉得我应该访问的是节点1（比较智能的客户端本地会存一个slot到节点的map）</li>
<li>对应的slot已经从节点一移走了，但是节点1的clusterNode里存了每个节点和槽对应的关系，所以返回一个MOVED，告诉客户端应该去节点2</li>
<li>对应的slot正好在从节点1挪到节点2，节点1会返回一个ASK和节点2的地址，客户端接到返回之后去问节点2数据是否在，节点2返回是否</li>
</ol>
<h3 id="节点间通信"><a href="#节点间通信" class="headerlink" title="节点间通信"></a>节点间通信</h3><h4 id="MEET"><a href="#MEET" class="headerlink" title="MEET"></a>MEET</h4><p>也就是建立集群的握手</p>
<p><img src="/../images/redis/meet.png" alt></p>
<h4 id="PING-PONG"><a href="#PING-PONG" class="headerlink" title="PING PONG"></a>PING PONG</h4><p><strong>ping：</strong></p>
<p>用于交换节点的元数据。每个节点每秒会向集群中其他节点发送 ping 消息，消息中封装了自身节点状态还有其他部分节点的状态数据，也包括自身所管理的槽信息等等。</p>
<p>这里的部分节点至少包含 3 个其它节点的信息，最多包含 （总节点数 - 2）个其它节点的信息。</p>
<p><strong>pong：</strong></p>
<p>meet和ping协议的响应，同样包含节点状态还有其他部分节点的信息</p>
<h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p>看了一眼机制也挺眼熟的（怎么感觉以前学通信学过），通过ping pong每个节点可以交换部分集群节点的数据，如果每个节点都定时挑几个节点去交换一下数据，最后就会获取整个集群的数据。而不是每个节点都要和每个节点建立通信，这样集群量大的时候通信压力也太大了</p>
<p>缺点大概就是信息会有滞后吧</p>
<p>节点多的话虽然集群通信压力可能小，但是信息滞后会导致重定向次数和概率变高，最后压力还是会大</p>
<h3 id="集群扩容和收缩"><a href="#集群扩容和收缩" class="headerlink" title="集群扩容和收缩"></a>集群扩容和收缩</h3><p>其他都不重要（才没有懒得去仔细研究呢），主要是slot配置和slot内数据在节点的移动</p>
<ol>
<li>扩容之后，需要有老的节点对新节点发cluster meet，让他加入新节点</li>
</ol>
<p><img src="/../images/redis/集群扩容.png" alt></p>
<p>图是csdn上抄的，<a href="https://blog.csdn.net/a745233700/article/details/112691126，看起来画的很清楚" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/112691126，看起来画的很清楚</a></p>
<h3 id="节点故障下线和恢复"><a href="#节点故障下线和恢复" class="headerlink" title="节点故障下线和恢复"></a>节点故障下线和恢复</h3><p>和sentinel一样，分为主观下线和客观下线</p>
<p>当故障节点下线后，如果是持有槽的主节点则需要在其从节点中找出一个替换它，从而保证高可用。然后就回到了前面的sentinel模式</p>
<blockquote>
<p>备注：如果集群中某个节点的master和slave节点都宕机了，那么集群就会进入fail状态，因为集群的slot映射不完整。如果集群超过半数以上的master挂掉，无论是否有slave，集群都会进入fail状态。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说，主从复制利用读写分离解决的是吞吐量的问题，sentinel模式在其基础上解决了节点宕机导致服务不可用的问题，而集群在此基础上利用分布式存储解决了动态缩扩容的问题</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/04/11/redis学习笔记三：单机数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/11/redis学习笔记三：单机数据库/" itemprop="url">
                  redis学习笔记三：单机数据库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-04-11 17:43:10 / Modified: 17:51:40" itemprop="dateCreated datePublished" datetime="2023-04-11T17:43:10+08:00">2023-04-11</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="redisDB"><a href="#redisDB" class="headerlink" title="redisDB"></a>redisDB</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<p>里面的字典结构被称为 key space </p>
<p>好像就没什么好讲的了毕竟dict结构前面夜看到过emmmm，放张图吧</p>
<p><img src="/../images/redis/redisdb_dict结构.png" alt></p>
<h3 id="读写时的维护操作"><a href="#读写时的维护操作" class="headerlink" title="读写时的维护操作"></a>读写时的维护操作</h3><blockquote>
<ul>
<li>在读取一个键之后（读操作和写操作都要对键进行读取）， 服务器会根据键是否存在， 以此来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数， 这两个值可以在 INFO stats 命令的 <code>keyspace_hits</code> 属性和 <code>keyspace_misses</code> 属性中查看。</li>
<li>在读取一个键之后， 服务器会更新键的 LRU （最后一次使用）时间， 这个值可以用于计算键的闲置时间， 使用命令 OBJECT idletime  命令可以查看键 <code>key</code> 的闲置时间。</li>
</ul>
</blockquote>
<p>lru这个对象里提到过，可以计算闲置时间也可以用于一些算法的内存回收，<strong>hit数的作用则尚且不明确</strong></p>
<blockquote>
<ul>
<li>如果有客户端使用 WATCH 命令监视了某个键， 那么服务器在对被监视的键进行修改之后， 会将这个键标记为脏（dirty）， 从而让事务程序注意到这个键已经被修改过， 《事务》一章会详细说明这一点。</li>
<li>服务器每次修改一个键之后， 都会对脏（dirty）键计数器的值增一， 这个计数器会触发服务器的持久化以及复制操作执行， 《RDB 持久化》、《AOF 持久化》和《复制》这三章都会说到这一点。</li>
<li>如果服务器开启了数据库通知功能， 那么在对键进行修改之后， 服务器将按配置发送相应的数据库通知， 本章稍后讨论数据库通知功能的实现时会详细说明这一点。</li>
</ul>
</blockquote>
<p>这三个后面回提到的东西先记下，等提到再callback吧</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>一切的开始之前先讲一下redis持久化是个什么东西（也是四处看博客的总结而已）</p>
<p>像我们的mysql这种db是不需要持久化的，它本来就是存储在硬盘里的数据，经过关机重启之类的操作不会丢也不会怎么滴</p>
<p>但是redis是一种内存的存储，内存这种东西在重启之后会直接清空，在服务器进程结束重新启动之后需要持久化来恢复原来的redis存储。方案有两种，一个是RDB，一个是AOF</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB就是将某一时刻的数据集，用一种非常紧凑的格式的文件，保存下来（有点像快照）</p>
<p>但是很明显，如果没执行一次写操作就同步rdb，那效率就过于离谱了，可以用于数据集的备份甚至是版本控制</p>
<p><img src="/../images/redis//RDB文件结构.png" alt></p>
<p>上面是一个RDB文件的结构，下面是里面的一个数据库的结构</p>
<p><img src="/../images/redis/RDBdatabases结构.png" alt></p>
<blockquote>
<p><code>SELECTDB</code> 常量的长度为 <code>1</code> 字节， 当读入程序遇到这个值的时候， 它知道接下来要读入的将是一个数据库号码</p>
</blockquote>
<p>下面是key_value_pairs的结构</p>
<p><img src="/../images/redis/带过期时间键值对.png" alt></p>
<ol>
<li>如果没有过期时间的话前两格没有，直接从类型开始</li>
<li><code>TYPE</code> 记录了 <code>value</code> 的类型， 长度为 <code>1</code> 字节，也就是上面对象里面对象类型或者底层编码，比如<code>REDIS_RDB_TYPE_STRING</code></li>
</ol>
<p><strong>键值对value结构</strong></p>
<p><a href="https://www.w3cschool.cn/hdclil/yohs7ozt.html" target="_blank" rel="noopener">https://www.w3cschool.cn/hdclil/yohs7ozt.html</a></p>
<p>啊一个一个写感觉也没有必要，里面保存的其实就是前面讲到的对象结构，要用的或者关心的时候回来看一眼吧，包括具体的保存结构，压缩方案之类的</p>
<p><strong>TBD</strong></p>
<p>RDB的产生和update逻辑是什么样子的？</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>append only file</p>
<p>AOF文件会把所有的写入动作都存进一个文件，并在服务器启动时，通过重新执行这些命令来还原数据集。</p>
<p><strong>命令追加</strong></p>
<p>就是客户端每做一个会改变存储的操作：比如set或者update，就会追加一个操作到缓冲区</p>
<p><strong>文件写入</strong></p>
<p>redis的eventloop，在每次接收客户端请求进行操作之后，都会考虑是否将aof缓冲区（aof_buf）的文件写入和保存到aof文件里</p>
<p><code>flushAppendOnlyFile</code> 函数的行为由服务器配置的 <code>appendfsync</code> 选项的值来决定</p>
<table>
<thead>
<tr>
<th style="text-align:left"><code>appendfsync</code> 选项的值</th>
<th style="text-align:left"><code>flushAppendOnlyFile</code> 函数的行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>always</code></td>
<td style="text-align:left">将 <code>aof_buf</code> 缓冲区中的所有内容写入并同步到 AOF 文件。</td>
</tr>
<tr>
<td style="text-align:left"><code>everysec</code></td>
<td style="text-align:left">将 <code>aof_buf</code> 缓冲区中的所有内容写入到 AOF 文件， 如果上次同步 AOF 文件的时间距离现在超过一秒钟， 那么再次对 AOF 文件进行同步， 并且这个同步操作是由一个线程专门负责执行的。</td>
</tr>
<tr>
<td style="text-align:left"><code>no</code></td>
<td style="text-align:left">将 <code>aof_buf</code> 缓冲区中的所有内容写入到 AOF 文件， 但并不对 AOF 文件进行同步， 何时同步由操作系统来决定。</td>
</tr>
</tbody>
</table>
<p><strong>文件写入数据丢失问题</strong></p>
<p>aof操作是写在内存缓冲区的，那么如果突然宕机了又改怎么办</p>
<p>不同的函数配置丢失的数据就不一样，always最多丢失的就是一个eventloop内的缓冲区指令。everysec丢失的是一秒的指令，no则会丢失上次同步之后写入的所有的数据</p>
<p>但是相反，always因为每次写入之后都要同步，所以写入效率是最低的，no无需执行同步操作，所以写入效率自然也快很多</p>
<p>aof可以很好地解决数据同步和避免数据丢失的问题，但是同时aof的文件大小会随着redis运行的时长变得非常非常非常离谱=》怎样把rdb和aof组合？</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="io多路复用：i-o-multiplexing"><a href="#io多路复用：i-o-multiplexing" class="headerlink" title="io多路复用：i/o multiplexing"></a>io多路复用：i/o multiplexing</h4><p>简单一点来说就和我们go channel的select逻辑很像，只不过从同时监听多个channel变成了同时监听多个fd，不需要一个线程一个fd这么消耗资源还不好维护</p>
<p>select 和 epoll的区别：后面再说吧不属于redis范畴</p>
<h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h4><p>用多路复用的规则去监听事件，监听到了之后就扔给handler去处理事件（简单来说就是这样</p>
<h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>发现了redis设计与实现这本书一个诡异的问题，经常是上来连这个东西是什么干什么用的都不解释就哐哐哐一顿原理输出</p>
<p>文件事件是redis服务端通过socket连接客户端，并且处理客户端操作的抽象</p>
<p><img src="/../images/redis/文件事件处理.png" alt></p>
<ol>
<li>每个套接字执行连接，读取，写入，关闭等操作</li>
<li>每个操作产生一个文件事件，被io多路复用程序写入队列扔给分派器<ol>
<li>因为io多路复用本质是个block逻辑，所以只有一个套接字内的文件事件都结束了，多路复用程序才会执行下一次event loop并且把下一个套接字的事件扔进队列</li>
</ol>
</li>
<li>分派器会根据文件事件类型调度不同的处理器去处理</li>
</ol>
<p>多路复用的函数都是套了linux epoll，select之类的 函数</p>
<blockquote>
<p>Redis 为文件事件编写了多个处理器， 这些事件处理器分别用于实现不同的网络通讯需求， 比如说：</p>
<ul>
<li>为了对连接服务器的各个客户端进行应答， 服务器要为监听套接字关联连接应答处理器。</li>
<li>为了接收客户端传来的命令请求， 服务器要为客户端套接字关联命令请求处理器。</li>
<li>为了向客户端返回命令的执行结果， 服务器要为客户端套接字关联命令回复处理器。</li>
<li>当主服务器和从服务器进行复制操作时， 主从服务器都需要关联特别为复制功能编写的复制处理器。</li>
<li>等等。</li>
</ul>
<p>在这些事件处理器里面， 服务器最常用的要数与客户端进行通信的连接应答处理器、 命令请求处理器和命令回复处理器。</p>
</blockquote>
<p><img src="/../images/redis/redis文件事件实现.png" alt></p>
<p> <code>AE_READABLE</code> 事件和 <code>AE_WRITABLE</code> 事件的概念是说，这个socket本身是可读的还是可写的，比如建立连接，读取指令就是readable事件，向socket写入返回结果，就是writable事件（感觉书里把它写复杂了</p>
<p>备注：</p>
<p>I/O 多路复用程序允许服务器同时监听套接字的 <code>AE_READABLE</code> 事件和 <code>AE_WRITABLE</code> 事件， 如果一个套接字同时产生了这两种事件， 那么文件事件分派器会优先处理 <code>AE_READABLE</code> 事件， 等到 <code>AE_READABLE</code> 事件处理完之后， 才处理 <code>AE_WRITABLE</code> 事件。</p>
<p>这也就是说， 如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字。</p>
<h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>时间事件是redis内部的另一种事件类型，时间事件可以实现定时或周期两种逻辑</p>
<blockquote>
<p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
</blockquote>
<p>上面讲到的处理持久化aof的逻辑，就是在一个叫serverCron的函数里执行的，而有一个时间事件就是执行serverCron函数。</p>
<p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：</p>
<blockquote>
<p>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等</p>
<p>清理数据库中的过期键值对。</p>
<p>关闭和清理连接失效的客户端</p>
<p>尝试进行AOF或RDB持久化操作</p>
<p>如果服务器是主服务器，那么对从服务器进行定期同步</p>
<p>如果处于集群模式，对集群进行定期同步和连接测</p>
</blockquote>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>这里的客户端指的是在服务器内，每个连接的客户端都会被用redisClient结构体保存下来</p>
<h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> CLIENT list</span></span><br><span class="line">id=-1498257551710864375 addr=9.137.217.100:51572 fd=96 name= cmd=ping age=99963 idle=21 proxy=3062a189cc80bde541b30efc7a5721c37c89df49</span><br></pre></td></tr></table></figure>
<ul>
<li>fd: 套接字描述符，普通客户端fd&gt;0，伪客户端fd=-1，伪客户端处理的命令请求来源于 AOF 文件或者 Lua 脚本， 而不是网络， 所以这种客户端不需要套接字连接， 自然也不需要记录套接字描述符。</li>
<li>name：客户端名称，正常情况下客户端名称都是么有的，使用 CLIENT_SETNAME 命令可以为客户端设置一个名字</li>
<li>flags：客户端的身份和状态-具体以后再看文档吧</li>
<li>age：客户端的连接时间（s）</li>
</ul>
<h3 id="客户端命令执行"><a href="#客户端命令执行" class="headerlink" title="客户端命令执行"></a>客户端命令执行</h3><ol>
<li>客户端发出的命令会被放到redisClient的输入缓冲区 <code>querybuf</code>，querybuf的大小是动态的，但是如果超过1个G客户端就会自动断开，but redis-cli 终端默认只能输入 4095 个字符，用脚手架倒是不会超过就是了</li>
<li>分析存在缓冲区的命令，并且把命令解析之后存在 argc 和 argv里面，其中argc负责记录argv的长度，argv[0] 默认是command，后面是按顺序输入的参数（这倒就是普通的读输入逻辑</li>
</ol>
<p><img src="/../images/redis/redis_client命令.png" alt></p>
<ol start="3">
<li>根据argv[0] 的command，在命令表找到对应的redisCommand，并且把客户端的cmd指针指向对应的redisCommand，之后客户端就可以执行command命令</li>
</ol>
<p><img src="/../images/redis/redisCommandDict.png" alt></p>
<ol start="4">
<li>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，客户端的缓冲区有两种，固定大小缓冲区和可变大小缓冲区。简单来说就是固定大小缓冲区是自带默认的，大小默认是16kb。如果返回很大固定大小缓冲区塞不下就会用到可变大小缓冲区，可变大小缓冲区的数据结构是个链表</li>
</ol>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>这个是抄书的一个，上面讲过的客户端发送命令到收到ok的大致过程：（大家都知道就是了</p>
<blockquote>
<p>那么从客户端发送 <code>SET KEY VALUE</code> 命令到获得回复 <code>OK</code> 期间， 客户端和服务器共需要执行以下操作：</p>
<ol>
<li>客户端向服务器发送命令请求 <code>SET KEY VALUE</code> 。</li>
<li>服务器接收并处理客户端发来的命令请求 <code>SET KEY VALUE</code> ， 在数据库中进行设置操作， 并产生命令回复 <code>OK</code> 。</li>
<li>服务器将命令回复 <code>OK</code> 发送给客户端。</li>
<li>客户端接收服务器返回的命令回复 <code>OK</code> ， 并将这个回复打印给用户观看。</li>
</ol>
</blockquote>
<p>中间的细节：不想写感觉除了上一节写的东西之外也就是多讲了一些细节，比如参数校验，身份验证还有一些执行之后的后续工作，有需要再看吧</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果说上一个章节是介绍了redis在内存中保存的数据结构的话，这个章节介绍的就是redis服务器是怎么运行的，包括持久化存储逻辑，事件处理，客户端连接，处理客户端请求等（感觉这本书意外地写得挺清楚</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/12/07/redis学习笔记二：对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/12/07/redis学习笔记二：对象/" itemprop="url">
                  redis学习笔记二：对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2022-12-07 00:35:03" itemprop="dateCreated datePublished" datetime="2022-12-07T00:35:03+08:00">2022-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2023-04-11 17:46:31" itemprop="dateModified" datetime="2023-04-11T17:46:31+08:00">2023-04-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面介绍的所有的数据类型都是属于redis的底层数据结构，对象可以理解为是对底层数据结构的封装。</p>
<p>Redis 使用对象来表示数据库中的键和值，每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>表：对象的类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型常量</th>
<th style="text-align:left">对象的名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left">字符串对象（底层就是简单的字符串结构）</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left">列表对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left">哈希对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left">集合对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left">有序集合对象</td>
</tr>
</tbody>
</table>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>与此同时，对象只是一种数据类型对外的表征展示，同一个类型对象的底层数据结构可以是不一样的，这个底层结构的就是用编码<code>encoding</code> 来记录的。</p>
<p>对象的编码</p>
<table>
<thead>
<tr>
<th style="text-align:left">编码常量</th>
<th style="text-align:left">编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_INT</code></td>
<td style="text-align:left"><code>long</code> 类型的整数</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td style="text-align:left"><code>embstr</code> 编码的简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_RAW</code></td>
<td style="text-align:left">简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left">字典</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td style="text-align:left">双端链表</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">压缩列表</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_INTSET</code></td>
<td style="text-align:left">整数集合</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td style="text-align:left">跳跃表和字典</td>
</tr>
</tbody>
</table>
<hr>
<p>每种类型的对象都至少使用了两种不同的编码， 下面的表列出了每种类型的对象可以使用的编码。</p>
<p>不同类型和编码的对象</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">编码</th>
<th style="text-align:left">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_INT</code></td>
<td style="text-align:left">使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td style="text-align:left">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_RAW</code></td>
<td style="text-align:left">使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td style="text-align:left">使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left">使用字典实现的哈希对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_INTSET</code></td>
<td style="text-align:left">使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left">使用字典实现的集合对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td style="text-align:left">使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。</p>
</blockquote>
<p>就比如上面介绍压缩列表时提到的，在数据量不大的背景下（查找效率影响不大），为了优化存储空间就会被处理成压缩列表。</p>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>虽然名字叫字符串对象，但是实际上是简单赋值对象，毕竟字符串对象的编码可以是<code>int</code> 、 <code>raw</code> 或者 <code>embstr</code>。</p>
<p>浮点数也就是 <code>long double</code> 在redis底层也是存的字符串（也就是后两个），读写的时候都分别转一下。</p>
<h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p>顺便来说一下对象结构的应用，如果执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET KEY 10000</span><br></pre></td></tr></table></figure>
<p>那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code>属性里面（将 <code>void*</code> 转换成 <code>long</code> ）， 并将字符串对象的编码设置为 <code>int</code> 。当然这里的long看起来不是redis自定义的数据结构而是单纯的long类型数据结构</p>
<h4 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h4><p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 <code>39</code> 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 <code>raw</code> 。</p>
<p>看一下这下这个对象长啥样</p>
<p><img src="/../images/redis/raw编码字符串对象.png" alt></p>
<p>嘛感觉还是非常生动形象的。</p>
<h4 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h4><p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 <code>39</code> 字节， 那么字符串对象将使用 <code>embstr</code> 编码的方式来保存这个字符串值。</p>
<p>本质上来说embstr也是和前面的压缩列表一样利用连续地址空间节约内存的东西（看得出对redis来说内存有多珍贵了）</p>
<p><strong>embstr和raw的区别：</strong></p>
<p>raw分配内存的时候，分别初始化redisObj和sdshdr，然后分配两块地址空间</p>
<p>而embstr分配内存时，一口气初始化redisObj和sdshdr，初始化成一块连续的地址空间。</p>
<p>嘛至于文档里说的调用和释放少掉用一次函数这种事情并不是重点啦</p>
<blockquote>
<p>（这段是抄的但是讲的很有道理）至于为什么是39，这个讲起来就比较复杂了，我就慢点说。<br>embstr是一块连续的内存区域，由redisObject和sdshdr组成。其中redisObject占16个字节，当buf内的字符串长度是39时，sdshdr的大小为8+39+1=48，那一个字节是’\0’。加起来刚好64。是不是发现了什么？</p>
</blockquote>
<h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><ol>
<li>int -&gt; raw 当本来被设置为int的value变成字符串之后，就要进行编码转换</li>
<li>embstr -&gt; raw embstr是个只读的，所以只要对embstr进行了编辑，就会变成raw</li>
</ol>
<p>同时 embstr 是只读的，也就是说其他数据类型不能转embstr，</p>
<p>字符串应该是使用率最高的东西了（我觉得）</p>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><h4 id="ziplist-和-linkedlist"><a href="#ziplist-和-linkedlist" class="headerlink" title="ziplist 和 linkedlist"></a>ziplist 和 linkedlist</h4><p>一共有 <code>ziplist</code> 和 <code>linkedlist</code>两种</p>
<p>怎么看ziplist都是压缩列表的样子</p>
<p>linkedlist就是列表，在redis里是个双端列表的数据结构</p>
<p>不如在这里把文档里的例子都给一下，正好方便理解前面的东西（其实就是抄书）</p>
<p>Key: numbers value : 1 “three” 5</p>
<p><img src="/../images/redis/压缩列表.png" alt="压缩列表"></p>
<p><img src="/../images/redis/链表.png" alt="链表"></p>
<h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li>
<li>列表对象保存的元素数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的列表对象需要使用 <code>linkedlist</code> 编码。</p>
<p>这俩是可以在配置文件里配置的</p>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><h4 id="ziplist-和-hashtable"><a href="#ziplist-和-hashtable" class="headerlink" title="ziplist 和 hashtable"></a>ziplist 和 hashtable</h4><p>先说hashtable吧，看起来就无比正常，底层是前面的字典结构，这里书上是这么写的：</p>
<blockquote>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
</blockquote>
<p>根据前面看过的字典可以知道，dict-&gt;dictht-&gt;[]dictEntry，一个dictEntry里保存一个键值对，这个键是个指针，值可以是整数也可以是指针，书上的描述的意思应该就是每个键和值都指向了一个字符串对象的意思，嗯应该是的。</p>
<p>ziplist也就是压缩列表，数组的压缩列表很好理解嘛一个一个压起来，每个节点存个长度之类的东西就行。但是哈希有键值对的概念，所以就是先放key再放value的顺序压起来</p>
<blockquote>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
</blockquote>
<p>找肯定也是遍历找嘛这个不用怀疑，就不会和字典一样可以根据hash算法来加快找的速度</p>
<h4 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h4><p>用ziplist的条件和前面的数组一样，只要不满足条件就会从ziplist变成hashtable</p>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><h4 id="intset-和-hashtable"><a href="#intset-和-hashtable" class="headerlink" title="intset 和 hashtable"></a>intset 和 hashtable</h4><p>intset也就是前面的整数集合，这个比较好理解吧就是一堆整数集合。</p>
<p>hashtable就很神奇了，键值对里只有key是作为存储的，值则被置为null。不过仔细想想也很好理解，利用hashtable作为字段在不在set里的查找逻辑嘛，平时自己不也是这么写的</p>
<h4 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h4><p>当集合对象可以同时满足以下两个条件时， 对象使用 <code>intset</code> 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p>
<p>当然了那个512也是个配置</p>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><h4 id="ziplist-和-skiplist"><a href="#ziplist-和-skiplist" class="headerlink" title="ziplist 和 skiplist"></a>ziplist 和 skiplist</h4><p>跳表在前面看数据结构的时候就提过是用来处理有序集合的，可以利用跳表提高查找效率。</p>
<p>实际上一个skiplist包含一个跳表和一个字典</p>
<blockquote>
<p><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现， 一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<p>跳表本身没什么好说的，改存啥就存啥</p>
<p>字典就比较神奇了，key：每个节点的值，value：每个节点的score</p>
<blockquote>
<p>值得一提的是， 虽然 <code>zset</code> 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
</blockquote>
<p>确实值得一提，不然肯定有人（比如我）会问在redis这种内存大过天的地方怎么会舍得分两份内存出来照顾有序集合的</p>
<p><strong>但是为什么要用两个数据结构存有序集合？</strong></p>
<p> <code>ZRANGE</code> 这种按顺序拿值的函数，那用跳表就ok了 O(nlogn)</p>
<p><code>ZSCORE</code> 是需要根据值来获取score O(1)</p>
<p>嘛这样就可以理解了</p>
<p>压缩列表也没啥好说的，就是比较小的时候挨个排一排存起来，第一个是值第二个是score</p>
<h4 id="编码转换-4"><a href="#编码转换-4" class="headerlink" title="编码转换"></a>编码转换</h4><p>当有序集合对象可以同时满足以下两个条件时， 对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 <code>128</code> 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li>
</ol>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>背景，redis很多操作都是针对特定对象执行的，比如set对字符串对象，hset则是对哈希对象执行，类型检查就是为了确保特定的类型执行特定的指令。</p>
<p>类型特定命令所进行的类型检查是通过 <code>redisObject</code> 结构的 <code>type</code> 属性来实现的：</p>
<ul>
<li>在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；</li>
<li>否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>其实就是不同编码支持同一个函数的情况下，这个指令就被认为支持多态，比如linkedList和zipList</p>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>redis利用引用计数来实现内存回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时， 引用计数的值会被初始化为 <code>1</code> ；</li>
<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</li>
</ul>
</blockquote>
<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>可是为什么这个对象会被多个程序引用呢，这就涉及到了对象共享逻辑。</p>
<p>比如你创建一个值为10的字符串对象，key a和key b对应的值都是10的时候，他们会指向同一个字符串对象：10。</p>
<p>说白了也就是为了节约内存。</p>
<blockquote>
<p>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 <code>0</code> 到 <code>9999</code> 的所有整数值， 当服务器需要用到值为 <code>0</code>到 <code>9999</code> 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>
</blockquote>
<p>当然这个数量也可以通过配置来修改</p>
<p>可以用 <code>OBJECT REFCOUNT</code> 来查看改对象引用量</p>
<p>比较有意思的是，目前Redis 只对包含整数值的字符串对象进行共享</p>
<p>简单来说原因就是时间复杂度-&gt;cpu耗时，整数匹配的时间复杂度为O(1) 而 字符串匹配的时间复杂度为 O(n)</p>
<p>而如果是一个哈希对象共享的话则会更加复杂，要判断键是否一致，再判断每个键下面的值是否一致，书上算出来的是O(n^2)，但是我总觉得是O(kn)</p>
<p>而且字符串被重复利用比例和整数相比要低很多</p>
<h3 id="空转时长"><a href="#空转时长" class="headerlink" title="空转时长"></a>空转时长</h3><p>用到的是redisobject里面的lru 属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>lru这个名字一出来就是老熟人了，lru记录了对象最后一次被命令程序访问的时间。用 <code>OBJECT IDLETIME</code> 命令可以打印出该对象的空转时长，也就是当前时间-lru</p>
<blockquote>
<p>键的空转时长还有另外一项作用： 如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Nina">
            
              <p class="site-author-name" itemprop="name">Nina</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">37</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nina</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  
  

  

  

  

  

  

</body>
</html>
