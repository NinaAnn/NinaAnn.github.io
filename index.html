<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="English">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Nina&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Nina&#39;s Blog">
<meta property="og:locale" content="English">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nina&#39;s Blog">






  <link rel="canonical" href="http://yoursite.com/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Nina's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="English">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Nina's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Good Good Study, Day Day Up</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/12/08/剑指offer-memo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/08/剑指offer-memo/" itemprop="url">
                  剑指offer memo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-12-08 17:28:48" itemprop="dateCreated datePublished" datetime="2023-12-08T17:28:48+08:00">2023-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2023-12-10 16:55:47" itemprop="dateModified" datetime="2023-12-10T16:55:47+08:00">2023-12-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数组中重复数字"><a href="#数组中重复数字" class="headerlink" title="数组中重复数字"></a>数组中重复数字</h2><p>题目：<a href="https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/" target="_blank" rel="noopener">https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/</a></p>
<p>解法：</p>
<ol>
<li>hashmap，最容易想到的解法，但是空间复杂度O(n)</li>
<li><p>能改变nums数组的背景下将值对应index的值变为-，重复遇到时值为负，但是会改变数组值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        key := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(num)))</span><br><span class="line">        <span class="keyword">if</span> nums[key] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">        &#125;</span><br><span class="line">        nums[key] = -nums[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二分法：在n个 1-n的数字中有重复，这个问题可以理解为，在数字 1到n/2 和 n/2到n两个范围中，重复数字落下的区间所拥有的数组数字量一定比一半要更多，用这个方式可以对 1-n的数字二分最后找到答案，时间复杂度O(nlogn)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">1</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (left+right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> leftNum,rightNum <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> num &gt; mid &amp;&amp; num &lt;= right &#123;</span><br><span class="line">                rightNum++</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt;= left &amp;&amp; num &lt;= mid &#123;</span><br><span class="line">                leftNum++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> leftNum &lt;= mid - left + <span class="number">1</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>环形链表：数字和对应下标值可以组成一个链表（当然是在数字本身是1-n的背景下），比如数组 [1,3,2,2] 组成的链表就是 1-&gt;3-&gt;2-&gt;2…，最后的2就会变成一个环形链表，可以用快慢指针找环形链表的方案求解，时间复杂度O(n)，空间复杂度O(1) 完美</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fast,slow,start <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        </span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        fast = nums[nums[fast]]</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == slow &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        start = nums[start]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>题目：<a href="https://leetcode.com/problems/search-a-2d-matrix-ii/submissions/1116268925/" target="_blank" rel="noopener">https://leetcode.com/problems/search-a-2d-matrix-ii/submissions/1116268925/</a></p>
<p>没啥老朋友+1，就是从左到右从上到下递增的二维数组怎么找数字</p>
<p>从右上和左下开始的思路是一样的，以从右上开始打个比方，就是</p>
<ul>
<li>如果matrix[a][b] &gt; target，那么对所有x,y, x &gt; a &amp;&amp; y &gt; b，都比target要大，也就是整个右下角，所以可以跳过右下角的遍历</li>
<li>如果matrix[a][b] &lt; target，那么对所有x,y, x &lt; a &amp;&amp; y &lt; b，都比target要小，所以不需要关心左上角</li>
<li>从右上开始的逻辑就是，右上角已经走过了，之后只需要对左下角接着遍历就ok了</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    m := <span class="built_in">len</span>(matrix)</span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line">    y := <span class="built_in">len</span>(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x == m || y &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> matrix[x][y] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> matrix[x][y] &gt; target &#123;</span><br><span class="line">            y --</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p>题目：<a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>老朋友加一，同时知道前序遍历（或后序遍历）和中序遍历就能够唯一确定一颗二叉树，而前序和后序则不能</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur := &amp;TreeNode&#123;</span><br><span class="line">        Val: preorder[<span class="number">0</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> inIndex <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i,in := <span class="keyword">range</span> inorder &#123;</span><br><span class="line">        <span class="keyword">if</span> in == preorder[<span class="number">0</span>] &#123;</span><br><span class="line">            inIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.Left = buildTree(preorder[<span class="number">1</span>:inIndex+<span class="number">1</span>], inorder[<span class="number">0</span>:inIndex])</span><br><span class="line">    cur.Right = buildTree(preorder[inIndex+<span class="number">1</span>:], inorder[inIndex+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用两个栈实现堆"><a href="#用两个栈实现堆" class="headerlink" title="用两个栈实现堆"></a>用两个栈实现堆</h2><p>题目：<a href="https://leetcode.com/problems/implement-queue-using-stacks/submissions/1116341974/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-queue-using-stacks/submissions/1116341974/</a></p>
<p>没什么好讲的+1，写着玩</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    In []<span class="keyword">int</span></span><br><span class="line">    Out []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.In = <span class="built_in">append</span>(this.In, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.Out) == <span class="number">0</span> &#123;</span><br><span class="line">        this.Out = <span class="built_in">append</span>(this.Out, this.In...)</span><br><span class="line">        this.In = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = this.Out[<span class="number">0</span>]</span><br><span class="line">    this.Out = this.Out[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.Out) == <span class="number">0</span> &#123;</span><br><span class="line">        this.Out = <span class="built_in">append</span>(this.Out, this.In...)</span><br><span class="line">        this.In = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.Out[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.Out) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.In) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Peek();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>题目：</p>
<ul>
<li><a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">https://leetcode.com/problems/fibonacci-number/</a></li>
<li><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/description/</a></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多写两步就是爬楼梯，爬楼梯的本质方法其实就是下面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n<span class="number">-1</span>) + climbStairs(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是显而易见这是个递归，时间复杂度O(2^n)，这么简单的问题用递归太消耗时间了（虽然确实很简单），climbStairs(n-1) 和 climbStairs(n-2) 一定遇见过很多次重复计算，如果我们把爬到每层楼梯的计算结果都存下来呢？</p>
<p>下面就是用空间换时间之后的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    steps := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    steps[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    steps[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i&lt;n; i++ &#123;</span><br><span class="line">        steps[i] = steps[i<span class="number">-2</span>] + steps[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞬间就变成了时间O(n)，空间O(n)的东西了</p>
<p>最后我们发现其实每次只关心step[n-1]和step[n-2]，所以就可以简化空间：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    one := <span class="number">1</span></span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line">        two := res</span><br><span class="line">        res += one</span><br><span class="line">        one = two</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>最后总结一下，dp本质上就是用空间换时间，主要的流程分为以下三步：</p>
<ol>
<li>写出递归公式 f(n) = f(n-k)+f(n-w) （简单打个比方）</li>
<li>用空间换时间方法写出dp解法</li>
<li>优化空间</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/12/08/刷题碎碎念一：环形链表快慢指针之为什么/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/08/刷题碎碎念一：环形链表快慢指针之为什么/" itemprop="url">
                  刷题碎碎念一：环形链表快慢指针之为什么
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-12-08 16:56:23 / Modified: 17:29:27" itemprop="dateCreated datePublished" datetime="2023-12-08T16:56:23+08:00">2023-12-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用快慢指针找环形链表是个非常非常非常常见的题型，之前在leetcode <a href="https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/" target="_blank" rel="noopener">find duplicate number</a> 见到了环形链表的解法，就顺手算了一下，算完给自己留个纪念（毕竟这可能是第三次算这东西了。。。）（每次都像是什么崭新的知识点）</p>
<h2 id="快慢指针找环形链表解法"><a href="#快慢指针找环形链表解法" class="headerlink" title="快慢指针找环形链表解法"></a>快慢指针找环形链表解法</h2><p>过分经典在这里放个链接顺便随便说说吧：<a href="https://leetcode.cn/problems/c32eOV/solutions/1037744/lian-biao-zhong-huan-de-ru-kou-jie-dian-vvofe/" target="_blank" rel="noopener">https://leetcode.cn/problems/c32eOV/solutions/1037744/lian-biao-zhong-huan-de-ru-kou-jie-dian-vvofe/</a></p>
<p>简单来说就是有一个快指针<code>fast</code>和一个慢指针<code>slow</code>，快指针每次往前走两步，慢指针每次往前走一步，如果两个指针最终相遇，那就说明这个链表是个环形链表</p>
<p><strong>那怎么找入环口呢?</strong></p>
<p>在两个节点相遇之后，掏出一个新的指针 <code>ptr</code> 指向链表头部，然后和 <code>slow</code> 每次往前走一步，这两个指针就会在入环点相遇</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>感觉真的算了很多次了但是每次都记不住QAQ</p>
<p>来随便写个个链表：</p>
<p>HEAD–B–…–C–Enter–D–…–Enter</p>
<p>假设：</p>
<ul>
<li>从head到Enter（不包含）一共<code>a</code>步</li>
<li>环内一共 <code>b</code> 节点（包含enter）</li>
<li>环内相遇时包含Enter和相遇节点一共距离enter <code>x</code> 节点</li>
<li>$\alpha$ 和 $\beta$ 是模数，任意</li>
</ul>
<p>那么当fast和slow相遇时，可以写个公式：</p>
<p>$a + x + \alpha b = 2(a+x)$</p>
<p>所以也就可以得知： 只要有一个 $x &gt;= 1 \&amp;\&amp; x &lt;= b$ 时满足：当 $a + x = \alpha b$ 就可以</p>
<p>那就很简单了，$x=b - (a \bmod b)$</p>
<p>再来看一下找入环口这件事情的公式，一共走了a+1步：</p>
<p>$a + 1 + x = \beta b + 1$</p>
<p>看 $a + x = \alpha b$，这个事情就是很自然而然的了对不对</p>
<p>好了欢乐结束了希望不要再忘了</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/04/26/redis学习笔记五：其他独立功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/26/redis学习笔记五：其他独立功能/" itemprop="url">
                  redis学习笔记五：其他独立功能
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-04-26 21:09:13 / Modified: 21:14:35" itemprop="dateCreated datePublished" datetime="2023-04-26T21:09:13+08:00">2023-04-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>开启事务：MULTI命令切换至事务状态</p>
<p>非事务状态：来一个get/set命令，立刻执行</p>
<p>事务状态：</p>
<ul>
<li>如果客户端发送的命令为 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令的其中一个， 那么服务器立即执行这个命令</li>
<li>如果不是这四个命令，扔进事务队列</li>
</ul>
<h3 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h3><p>每个 Redis 客户端都有自己的事务状态， 这个事务状态保存在客户端状态的 <code>mstate</code> 属性里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisClient &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 事务状态</span><br><span class="line">    multiState mstate;      /* MULTI/EXEC state */</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>
<p>事务状态包含一个事务队列， 以及一个已入队命令的计数器 （也可以说是事务队列的长度）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct multiState &#123;</span><br><span class="line"></span><br><span class="line">    // 事务队列，FIFO 顺序</span><br><span class="line">    multiCmd *commands;</span><br><span class="line"></span><br><span class="line">    // 已入队命令计数</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure>
<h3 id="执行EXEC"><a href="#执行EXEC" class="headerlink" title="执行EXEC"></a>执行EXEC</h3><blockquote>
<p>当一个处于事务状态的客户端向服务器发送 EXEC 命令时， 这个 EXEC 命令将立即被服务器执行： 服务器会遍历这个客户端的事务队列， 执行队列中保存的所有命令， 最后将执行命令所得的结果全部返回给客户端。</p>
</blockquote>
<p>执行失败：</p>
<p>当事务中的某个命令执行失败的时候，redis不会返回报错也不会回滚，而是会执行后面的命令</p>
<h3 id="监听Watch"><a href="#监听Watch" class="headerlink" title="监听Watch"></a>监听Watch</h3><h4 id="cas和aba问题"><a href="#cas和aba问题" class="headerlink" title="cas和aba问题"></a>cas和aba问题</h4><p>背景：cas和aba问题</p>
<p>cas：compare and swap，为了解决并发场景下同时访问同一个共享变量时导致的冲突问题，比如a在改变量env的时候b正好在改它</p>
<p>当然了也可以用锁，如果几个线程都是读线程，挨个获取锁就消耗了大量的时间和block的线程资源，所以锁也被称为悲观锁，就是假设了一种悲观场景，每次访问共享变量都会遇到冲突</p>
<p>cas就是很常用的乐观锁机制，它其实在代码逻辑上并没有上锁并且乐观的认为大部分人来访问它就是为了读而已，遇到冲突是很少的场景</p>
<blockquote>
<p>CAS 的思想很简单：三个参数，一个当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false</p>
</blockquote>
<p>在这里抄一点来自java的cas使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = <span class="keyword">this</span>.getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，利用cas来实现原子操作而不是真的搞个自旋锁，去比较获取的值和预期是否一致，一致就认为没有其他线程在改动变量，当然了cas底层的compare和swap操作本身还是可以用自旋锁去实现的</p>
<p>当然了就想在多读少写的情况下用自旋锁太耗时一样，如果是多写少读的场景就会有很多线程陷入无限循环，会给cpu带来大量的开销</p>
<p>aba问题：当另一个线程先把变量env=a改成env=b，又改成了env=a，而改动因为执行速度很快恰好没有被捕捉到，那还是会出现多个线程同时改一个变量的场景</p>
<p>当然为了解决aba问题不同的系统用了不同的改进方法，比如java就加了版本号的概念，每次修改也会把版本号+1</p>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>再回到redis，redis事务中watch的执行就是用了类似cas的乐观锁机制，不过它不是在执行的时候去compare，而是，肤浅的理解就是从watch指令开始就盯住对应的变量，一旦变量发生改动就通知客户端，取消事务，也就避免了aba问题</p>
<p>注意：在redis中只要exec开始执行就不会再有回滚之类的任何操作，所以watch的校验都是在exec之前的，exec执行后就会取消对所有键的监控，所以watch的意义是阻止执行</p>
<p>给个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH name</span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>
<h2 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h2><p>不想看用到再说</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/04/13/redis学习笔记四：多机数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/13/redis学习笔记四：多机数据库/" itemprop="url">
                  redis学习笔记四：多机数据库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-04-13 18:08:10 / Modified: 19:31:08" itemprop="dateCreated datePublished" datetime="2023-04-13T18:08:10+08:00">2023-04-13</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ol>
<li>从服务器发送sync请求到主服务器</li>
<li>主服务器生成RDB，并把之后的写命令都扔进一个缓冲区</li>
<li>主服务器把RDB发给从服务器，从服务器初始化</li>
<li>主服务器把缓冲区命令发给从服务器，从服务器执行，使得两边数据一致</li>
</ol>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>同步是在从服务器创建的时候从主服务器同步数据，命令传播是在主服务器的数据变动的时候把写命令同步给从服务器的行为</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>断线导致丢失数据的情况要怎么办？</p>
<p>– 同步：重同步</p>
<p>完整重同步和同步是一样，就是用在初始化同步数据</p>
<p>部分重同步则是用来处理断线后重复制的情况</p>
<blockquote>
<p>部分重同步用于处理断线后重复制的情况：当从服务器在断线后重新连接到主服务器时，如果条件允许，主服务器可以将断线后这一段时间执行的血命令发送给从服务器，从服务器只接收并执行这些写命令，就可以将从服务器数据库的状态更新至主服务器当前的状态。</p>
</blockquote>
<ol>
<li>偏移量：主服务器和从服务器分别维护一个复制偏移量，主服务器发N个消息就给自己的偏移量+N，从服务器收到N个就把自己的偏移量+N，这样一对就知道少了啥了</li>
<li>复制积压缓冲区：一块大小固定的缓冲区，主服务器会把自己收到的写命令和对应的offset都存在里面，对了一下偏移量，如果对应偏移量的数据还在缓冲区就直接把后面的指令给从服务器，不在缓冲区的话就执行完整重同步</li>
<li>服务器运行ID：从服务器在初始化复制的时候会把对应的主服务器id存下来，从服务器断线重启之后向主服务器发请求，如果id和主服务器id是同一个，就执行部分重同步，不一样（不大理解为啥会不一样）就完整重同步</li>
</ol>
<p>– 命令传播：心跳检测</p>
<p>在命令传播阶段，从服务器会每秒给主服务器发一个当前offset</p>
<ol>
<li>监测连接状态，一秒以后没收到连接可能就有问题了</li>
<li>如果连接正常的从服务器少于一个数量或者延迟很大的时候，主服务器可以拒接写入</li>
<li>offset也可以用来监测是不是丢命令了</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点很明显，就是主从实现读写分离嘛，减少了主服务器的压力</p>
<p>缺点也很明显，主服务器挂了就没了，没有任何的容错能力，而且也没办法支持扩容之类的操作</p>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>唉又是那个毛病，开头能不能先介绍一下sentinel是啥</p>
<p>首先假定（好像不是假定）redis的集群模式是master-slave（好像确实就是），如果master挂了，需要再选一个master节点出来，并且把之前master的slave都转移到新的master头上，这个系统就叫做哨兵系统(sentinel)</p>
<p>当然了同时我们就可以利用sentinel系统监控各个节点的特征，获取节点信息配置监控告警等</p>
<p>受不了了怎么还看到了raft，感觉自己在看hdfs和zk，sentinel集群和zk集群感觉其实真的差不多</p>
<p>TBD：</p>
<p>有空自己开一下sentinel模式试试看</p>
<p>简单来说就是sentinel系统本身就是一个节点，但是这个节点和普通redis节点不一样的是它开启了sentinel模式，同时command表也就不支持set之类的操作，而是pong这样的sentinel模式需要的命令</p>
<h3 id="启动连接"><a href="#启动连接" class="headerlink" title="启动连接"></a>启动连接</h3><p>sentinel启动的最后一步是向被监视的主服务器建立网络连接，sentinel会建立两种异步网络连接：</p>
<blockquote>
<ul>
<li>一个是命令连接， 这个连接专门用于向主服务器发送命令， 并接收命令回复。</li>
<li>另一个是订阅连接， 这个连接专门用于订阅主服务器的 <code>__sentinel__:hello</code> 频道。</li>
</ul>
</blockquote>
<p>关于订阅连接究竟是为什么要出现，各种地方的解释不一样，有的文档（包括这本Redis设计与实现）说订阅连接是为了防止丢失信息，因为订阅连接是个长连接，所以即使命令连接的返回数据丢了，也可以从订阅连接里收到。另一个说法是订阅连接可以帮助sentinel发现其他sentinel，从而建立<strong>Sentinel集群</strong>，姑且我们认为两种都有吧</p>
<h3 id="获取slave节点"><a href="#获取slave节点" class="headerlink" title="获取slave节点"></a>获取slave节点</h3><p> Sentinel 以每十秒一次的频率向被监视的主服务器发送 INFO 命令，INFO命令会返回改主服务器下从服务器的信息。获取到从服务器的信息后，sentinel就可以向从服务器建立命令连接和订阅连接</p>
<h3 id="建立Sentinel集群"><a href="#建立Sentinel集群" class="headerlink" title="建立Sentinel集群"></a>建立Sentinel集群</h3><p>默认情况下，Sentinel每2s一次，向所有被监视的主服务器和从服务器所订阅的<em>sentinel</em>:hello频道上发送消息，消息中会携带Sentinel自身的信息和主服务器的信息。这个信息先叫他频道消息。</p>
<p>因为每个sentinel都会向每个监视的服务器发频道消息，所以对于监视同一个服务器的多个sentinel来说，sentinel可以通过频道消息感知到其他sentinel的存在。</p>
<p><strong>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接</strong>（但是不创建订阅连接）</p>
<p><img src="/../images/redis/sentinel集群.png" alt></p>
<p>感想就是如果还想研究细节可以去再学一遍zk</p>
<h3 id="发现下线"><a href="#发现下线" class="headerlink" title="发现下线"></a>发现下线</h3><p>主观下线：</p>
<blockquote>
<p>默认情况下，Sentinel每秒一次向所有与它建立了命令连接的实例(包括主服务器、从服务器和其他Sentinel)发送PING命令，并根据回复判断实例是否在线。如果在Sentinel配置文件中的down-after-milliseconds毫秒内，连接向Sentinel返回无效回复，那么Sentinel就会认为该实例<strong>主观下线(SDown)</strong>。</p>
</blockquote>
<p>sentinel认为这个服务器主观下线之后，就会去检查它是不是真的下线了，也就是客观下线：</p>
<blockquote>
<p>为了确认是否真的下线，这个Sentinel会向同时监控这个主服务器的所有其他Sentinel发送查询命令，判断它们是否也任务主服务器下线(包括主观下线和客观下线)。如果达到Sentinel配置中的quorum数量的Sentinel实例都判断主服务器为主观下线，则该主服务器就会被判定为<strong>客观下线</strong>。</p>
</blockquote>
<h3 id="leader-sentinel选举"><a href="#leader-sentinel选举" class="headerlink" title="leader sentinel选举"></a>leader sentinel选举</h3><p>看到了吗熟悉的raft</p>
<p>说起来在这里放个raft的论文网址：<a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14" target="_blank" rel="noopener">https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14</a> 以后方便找</p>
<p>稍微简单解释一下，就是判定服务器为客观下线的sentinel节点可以发起选举，选举拿到半数以上赞成票并且超过一个设定阈值（<strong>quorum 值</strong>这个东西看上去像redis原创的？）就能当leader</p>
<p>至于具体的投票限制平票方案等等还是去看raft吧，反正就是选了个leader sentinel出来</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><ol>
<li>选新master。当然是有一些条件的<ol>
<li>过滤掉下线节点，过滤掉最近5s没有回复sentinel info的节点</li>
<li>选conf配置里设定优先级高的节点</li>
<li>优先级一样的话选复制偏移量最大的</li>
</ol>
</li>
<li>将所有从服务器改为复制新的主服务器。</li>
<li>将已下线的主服务器设置为新的主服务器的从服务器。</li>
</ol>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>master-slave的运行本身基于主从复制模式，所以该有的还是有</li>
<li>master挂掉就可以自动切换</li>
</ol>
<p>缺点：</p>
<ol>
<li>扩容还是不支持，容量还是依赖master节点机器配置</li>
<li>不知道算不算缺点的缺点，运行sentinel集群需要消耗额外的资源</li>
</ol>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>也来简单介绍一下，集群模式和sentinel模式是两种不一样的模式，集群模式的逻辑就是去中心化，每个节点都和集群内其他节点有连接，集群内部也可以设置主从，比如六个节点的话可以设置三主三从，主挂了从将自动变成主节点，但是和前面的读写分离不大一样，这里从节点主要是拿来做热备的，因为分布式存储本身就解决了吞吐量的问题（个人看书的理解</p>
<p>同时集群和前面两种模式不一样的是，每个主节点保存的东西都是不一样的，也就是终于转变为了分布式存储（可喜可贺）</p>
<p>集群本身的启动，集群的搭建和主从设置都是要在启动的时候通过配置实现的。    </p>
<p>连接各个节点的工作可以使用 CLUSTER MEET 命令来完成， 该命令的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>我猜哈我猜，在配置里配好集群节点之后，每个节点启动的时候会执行cluster meet，将对应的节点加到自己所属的集群中</p>
<h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p>一个节点就是一个运行在集群模式下的 Redis 服务器， Redis 服务器在启动时会根据 <code>cluster-enabled</code> 配置选项的是否为 <code>yes</code> 来决定是否开启服务器的集群模式。</p>
<p>集群模式下其他都是都是正常运行，同时<code>serverCon</code>会调用<code>clusterCron</code> 函数来执行在集群模式下需要执行的常规操作</p>
<p>集群相关的信息会被保存在 <code>cluster.h/clusterNode</code> 结构， <code>cluster.h/clusterLink</code> 结构， 以及 <code>cluster.h/clusterState</code> 结构里面</p>
<h4 id="clusterNode"><a href="#clusterNode" class="headerlink" title="clusterNode"></a>clusterNode</h4><p>每个节点都会使用一个 <code>clusterNode</code> 结构来记录自己的状态， 并为集群中的所有其他节点（包括主节点和从节点）都创建一个相应的<code>clusterNode</code> 结构， 以此来记录其他节点的状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的名字，由 40 个十六进制字符组成</span></span><br><span class="line">    <span class="comment">// 例如 68eef66df23420a5862208ef5b1a7005b806f2ff</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点标识</span></span><br><span class="line">    <span class="comment">// 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），</span></span><br><span class="line">    <span class="comment">// 以及节点目前所处的状态（比如在线或者下线）。</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的 IP 地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的端口号</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="clusterLink"><a href="#clusterLink" class="headerlink" title="clusterLink"></a>clusterLink</h4><p>clusterLink保存的是连接到节点所需要的连接信息，还挺明显的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出缓冲区，保存着等待发送给其他节点的消息（message）。</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与这个连接相关联的节点，如果没有的话就为 NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure>
<h4 id="clusterState"><a href="#clusterState" class="headerlink" title="clusterState"></a>clusterState</h4><p>最后， 每个节点都保存着一个 <code>clusterState</code> 结构， 这个结构记录了在当前节点的视角下， 集群目前所处的状态 —— 比如集群是在线还是下线， 集群包含多少个节点， 集群当前的配置纪元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的状态：是在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群中至少处理着一个槽的节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群节点名单（包括 myself 节点）</span></span><br><span class="line">    <span class="comment">// 字典的键为节点的名字，字典的值为节点对应的 clusterNode 结构</span></span><br><span class="line">    dict *nodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>redis集群引入了哈希槽（hash slot）的概念，Redis 集群有16384 个哈希槽，每个节点负责一部分hash槽，每个key通过对16384取mod来决定自己的数据放在哪个hash槽，这样在节点增加或删除的时候，只要通过改变一部分hash槽的归属就可以实现</p>
<h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p>作为一个去中心化的东西，自然没有一个路由器专门接收请求根据slot扔给对应的节点，无论Redis 的客户端访问集群中的哪个节点都可以路由到对应的节点上</p>
<ol>
<li>客户端算了一下觉得我应该访问的是节点1（比较智能的客户端本地会存一个slot到节点的map）</li>
<li>对应的slot已经从节点一移走了，但是节点1的clusterNode里存了每个节点和槽对应的关系，所以返回一个MOVED，告诉客户端应该去节点2</li>
<li>对应的slot正好在从节点1挪到节点2，节点1会返回一个ASK和节点2的地址，客户端接到返回之后去问节点2数据是否在，节点2返回是否</li>
</ol>
<h3 id="节点间通信"><a href="#节点间通信" class="headerlink" title="节点间通信"></a>节点间通信</h3><h4 id="MEET"><a href="#MEET" class="headerlink" title="MEET"></a>MEET</h4><p>也就是建立集群的握手</p>
<p><img src="/../images/redis/meet.png" alt></p>
<h4 id="PING-PONG"><a href="#PING-PONG" class="headerlink" title="PING PONG"></a>PING PONG</h4><p><strong>ping：</strong></p>
<p>用于交换节点的元数据。每个节点每秒会向集群中其他节点发送 ping 消息，消息中封装了自身节点状态还有其他部分节点的状态数据，也包括自身所管理的槽信息等等。</p>
<p>这里的部分节点至少包含 3 个其它节点的信息，最多包含 （总节点数 - 2）个其它节点的信息。</p>
<p><strong>pong：</strong></p>
<p>meet和ping协议的响应，同样包含节点状态还有其他部分节点的信息</p>
<h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p>看了一眼机制也挺眼熟的（怎么感觉以前学通信学过），通过ping pong每个节点可以交换部分集群节点的数据，如果每个节点都定时挑几个节点去交换一下数据，最后就会获取整个集群的数据。而不是每个节点都要和每个节点建立通信，这样集群量大的时候通信压力也太大了</p>
<p>缺点大概就是信息会有滞后吧</p>
<p>节点多的话虽然集群通信压力可能小，但是信息滞后会导致重定向次数和概率变高，最后压力还是会大</p>
<h3 id="集群扩容和收缩"><a href="#集群扩容和收缩" class="headerlink" title="集群扩容和收缩"></a>集群扩容和收缩</h3><p>其他都不重要（才没有懒得去仔细研究呢），主要是slot配置和slot内数据在节点的移动</p>
<ol>
<li>扩容之后，需要有老的节点对新节点发cluster meet，让他加入新节点</li>
</ol>
<p><img src="/../images/redis/集群扩容.png" alt></p>
<p>图是csdn上抄的，<a href="https://blog.csdn.net/a745233700/article/details/112691126，看起来画的很清楚" target="_blank" rel="noopener">https://blog.csdn.net/a745233700/article/details/112691126，看起来画的很清楚</a></p>
<h3 id="节点故障下线和恢复"><a href="#节点故障下线和恢复" class="headerlink" title="节点故障下线和恢复"></a>节点故障下线和恢复</h3><p>和sentinel一样，分为主观下线和客观下线</p>
<p>当故障节点下线后，如果是持有槽的主节点则需要在其从节点中找出一个替换它，从而保证高可用。然后就回到了前面的sentinel模式</p>
<blockquote>
<p>备注：如果集群中某个节点的master和slave节点都宕机了，那么集群就会进入fail状态，因为集群的slot映射不完整。如果集群超过半数以上的master挂掉，无论是否有slave，集群都会进入fail状态。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说，主从复制利用读写分离解决的是吞吐量的问题，sentinel模式在其基础上解决了节点宕机导致服务不可用的问题，而集群在此基础上利用分布式存储解决了动态缩扩容的问题</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/04/11/redis学习笔记三：单机数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/11/redis学习笔记三：单机数据库/" itemprop="url">
                  redis学习笔记三：单机数据库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-04-11 17:43:10 / Modified: 17:51:40" itemprop="dateCreated datePublished" datetime="2023-04-11T17:43:10+08:00">2023-04-11</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="redisDB"><a href="#redisDB" class="headerlink" title="redisDB"></a>redisDB</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<p>里面的字典结构被称为 key space </p>
<p>好像就没什么好讲的了毕竟dict结构前面夜看到过emmmm，放张图吧</p>
<p><img src="/../images/redis/redisdb_dict结构.png" alt></p>
<h3 id="读写时的维护操作"><a href="#读写时的维护操作" class="headerlink" title="读写时的维护操作"></a>读写时的维护操作</h3><blockquote>
<ul>
<li>在读取一个键之后（读操作和写操作都要对键进行读取）， 服务器会根据键是否存在， 以此来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数， 这两个值可以在 INFO stats 命令的 <code>keyspace_hits</code> 属性和 <code>keyspace_misses</code> 属性中查看。</li>
<li>在读取一个键之后， 服务器会更新键的 LRU （最后一次使用）时间， 这个值可以用于计算键的闲置时间， 使用命令 OBJECT idletime  命令可以查看键 <code>key</code> 的闲置时间。</li>
</ul>
</blockquote>
<p>lru这个对象里提到过，可以计算闲置时间也可以用于一些算法的内存回收，<strong>hit数的作用则尚且不明确</strong></p>
<blockquote>
<ul>
<li>如果有客户端使用 WATCH 命令监视了某个键， 那么服务器在对被监视的键进行修改之后， 会将这个键标记为脏（dirty）， 从而让事务程序注意到这个键已经被修改过， 《事务》一章会详细说明这一点。</li>
<li>服务器每次修改一个键之后， 都会对脏（dirty）键计数器的值增一， 这个计数器会触发服务器的持久化以及复制操作执行， 《RDB 持久化》、《AOF 持久化》和《复制》这三章都会说到这一点。</li>
<li>如果服务器开启了数据库通知功能， 那么在对键进行修改之后， 服务器将按配置发送相应的数据库通知， 本章稍后讨论数据库通知功能的实现时会详细说明这一点。</li>
</ul>
</blockquote>
<p>这三个后面回提到的东西先记下，等提到再callback吧</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>一切的开始之前先讲一下redis持久化是个什么东西（也是四处看博客的总结而已）</p>
<p>像我们的mysql这种db是不需要持久化的，它本来就是存储在硬盘里的数据，经过关机重启之类的操作不会丢也不会怎么滴</p>
<p>但是redis是一种内存的存储，内存这种东西在重启之后会直接清空，在服务器进程结束重新启动之后需要持久化来恢复原来的redis存储。方案有两种，一个是RDB，一个是AOF</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB就是将某一时刻的数据集，用一种非常紧凑的格式的文件，保存下来（有点像快照）</p>
<p>但是很明显，如果没执行一次写操作就同步rdb，那效率就过于离谱了，可以用于数据集的备份甚至是版本控制</p>
<p><img src="/../images/redis//RDB文件结构.png" alt></p>
<p>上面是一个RDB文件的结构，下面是里面的一个数据库的结构</p>
<p><img src="/../images/redis/RDBdatabases结构.png" alt></p>
<blockquote>
<p><code>SELECTDB</code> 常量的长度为 <code>1</code> 字节， 当读入程序遇到这个值的时候， 它知道接下来要读入的将是一个数据库号码</p>
</blockquote>
<p>下面是key_value_pairs的结构</p>
<p><img src="/../images/redis/带过期时间键值对.png" alt></p>
<ol>
<li>如果没有过期时间的话前两格没有，直接从类型开始</li>
<li><code>TYPE</code> 记录了 <code>value</code> 的类型， 长度为 <code>1</code> 字节，也就是上面对象里面对象类型或者底层编码，比如<code>REDIS_RDB_TYPE_STRING</code></li>
</ol>
<p><strong>键值对value结构</strong></p>
<p><a href="https://www.w3cschool.cn/hdclil/yohs7ozt.html" target="_blank" rel="noopener">https://www.w3cschool.cn/hdclil/yohs7ozt.html</a></p>
<p>啊一个一个写感觉也没有必要，里面保存的其实就是前面讲到的对象结构，要用的或者关心的时候回来看一眼吧，包括具体的保存结构，压缩方案之类的</p>
<p><strong>TBD</strong></p>
<p>RDB的产生和update逻辑是什么样子的？</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>append only file</p>
<p>AOF文件会把所有的写入动作都存进一个文件，并在服务器启动时，通过重新执行这些命令来还原数据集。</p>
<p><strong>命令追加</strong></p>
<p>就是客户端每做一个会改变存储的操作：比如set或者update，就会追加一个操作到缓冲区</p>
<p><strong>文件写入</strong></p>
<p>redis的eventloop，在每次接收客户端请求进行操作之后，都会考虑是否将aof缓冲区（aof_buf）的文件写入和保存到aof文件里</p>
<p><code>flushAppendOnlyFile</code> 函数的行为由服务器配置的 <code>appendfsync</code> 选项的值来决定</p>
<table>
<thead>
<tr>
<th style="text-align:left"><code>appendfsync</code> 选项的值</th>
<th style="text-align:left"><code>flushAppendOnlyFile</code> 函数的行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>always</code></td>
<td style="text-align:left">将 <code>aof_buf</code> 缓冲区中的所有内容写入并同步到 AOF 文件。</td>
</tr>
<tr>
<td style="text-align:left"><code>everysec</code></td>
<td style="text-align:left">将 <code>aof_buf</code> 缓冲区中的所有内容写入到 AOF 文件， 如果上次同步 AOF 文件的时间距离现在超过一秒钟， 那么再次对 AOF 文件进行同步， 并且这个同步操作是由一个线程专门负责执行的。</td>
</tr>
<tr>
<td style="text-align:left"><code>no</code></td>
<td style="text-align:left">将 <code>aof_buf</code> 缓冲区中的所有内容写入到 AOF 文件， 但并不对 AOF 文件进行同步， 何时同步由操作系统来决定。</td>
</tr>
</tbody>
</table>
<p><strong>文件写入数据丢失问题</strong></p>
<p>aof操作是写在内存缓冲区的，那么如果突然宕机了又改怎么办</p>
<p>不同的函数配置丢失的数据就不一样，always最多丢失的就是一个eventloop内的缓冲区指令。everysec丢失的是一秒的指令，no则会丢失上次同步之后写入的所有的数据</p>
<p>但是相反，always因为每次写入之后都要同步，所以写入效率是最低的，no无需执行同步操作，所以写入效率自然也快很多</p>
<p>aof可以很好地解决数据同步和避免数据丢失的问题，但是同时aof的文件大小会随着redis运行的时长变得非常非常非常离谱=》怎样把rdb和aof组合？</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="io多路复用：i-o-multiplexing"><a href="#io多路复用：i-o-multiplexing" class="headerlink" title="io多路复用：i/o multiplexing"></a>io多路复用：i/o multiplexing</h4><p>简单一点来说就和我们go channel的select逻辑很像，只不过从同时监听多个channel变成了同时监听多个fd，不需要一个线程一个fd这么消耗资源还不好维护</p>
<p>select 和 epoll的区别：后面再说吧不属于redis范畴</p>
<h4 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h4><p>用多路复用的规则去监听事件，监听到了之后就扔给handler去处理事件（简单来说就是这样</p>
<h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>发现了redis设计与实现这本书一个诡异的问题，经常是上来连这个东西是什么干什么用的都不解释就哐哐哐一顿原理输出</p>
<p>文件事件是redis服务端通过socket连接客户端，并且处理客户端操作的抽象</p>
<p><img src="/../images/redis/文件事件处理.png" alt></p>
<ol>
<li>每个套接字执行连接，读取，写入，关闭等操作</li>
<li>每个操作产生一个文件事件，被io多路复用程序写入队列扔给分派器<ol>
<li>因为io多路复用本质是个block逻辑，所以只有一个套接字内的文件事件都结束了，多路复用程序才会执行下一次event loop并且把下一个套接字的事件扔进队列</li>
</ol>
</li>
<li>分派器会根据文件事件类型调度不同的处理器去处理</li>
</ol>
<p>多路复用的函数都是套了linux epoll，select之类的 函数</p>
<blockquote>
<p>Redis 为文件事件编写了多个处理器， 这些事件处理器分别用于实现不同的网络通讯需求， 比如说：</p>
<ul>
<li>为了对连接服务器的各个客户端进行应答， 服务器要为监听套接字关联连接应答处理器。</li>
<li>为了接收客户端传来的命令请求， 服务器要为客户端套接字关联命令请求处理器。</li>
<li>为了向客户端返回命令的执行结果， 服务器要为客户端套接字关联命令回复处理器。</li>
<li>当主服务器和从服务器进行复制操作时， 主从服务器都需要关联特别为复制功能编写的复制处理器。</li>
<li>等等。</li>
</ul>
<p>在这些事件处理器里面， 服务器最常用的要数与客户端进行通信的连接应答处理器、 命令请求处理器和命令回复处理器。</p>
</blockquote>
<p><img src="/../images/redis/redis文件事件实现.png" alt></p>
<p> <code>AE_READABLE</code> 事件和 <code>AE_WRITABLE</code> 事件的概念是说，这个socket本身是可读的还是可写的，比如建立连接，读取指令就是readable事件，向socket写入返回结果，就是writable事件（感觉书里把它写复杂了</p>
<p>备注：</p>
<p>I/O 多路复用程序允许服务器同时监听套接字的 <code>AE_READABLE</code> 事件和 <code>AE_WRITABLE</code> 事件， 如果一个套接字同时产生了这两种事件， 那么文件事件分派器会优先处理 <code>AE_READABLE</code> 事件， 等到 <code>AE_READABLE</code> 事件处理完之后， 才处理 <code>AE_WRITABLE</code> 事件。</p>
<p>这也就是说， 如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字。</p>
<h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>时间事件是redis内部的另一种事件类型，时间事件可以实现定时或周期两种逻辑</p>
<blockquote>
<p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
</blockquote>
<p>上面讲到的处理持久化aof的逻辑，就是在一个叫serverCron的函数里执行的，而有一个时间事件就是执行serverCron函数。</p>
<p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括：</p>
<blockquote>
<p>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等</p>
<p>清理数据库中的过期键值对。</p>
<p>关闭和清理连接失效的客户端</p>
<p>尝试进行AOF或RDB持久化操作</p>
<p>如果服务器是主服务器，那么对从服务器进行定期同步</p>
<p>如果处于集群模式，对集群进行定期同步和连接测</p>
</blockquote>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>这里的客户端指的是在服务器内，每个连接的客户端都会被用redisClient结构体保存下来</p>
<h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> CLIENT list</span></span><br><span class="line">id=-1498257551710864375 addr=9.137.217.100:51572 fd=96 name= cmd=ping age=99963 idle=21 proxy=3062a189cc80bde541b30efc7a5721c37c89df49</span><br></pre></td></tr></table></figure>
<ul>
<li>fd: 套接字描述符，普通客户端fd&gt;0，伪客户端fd=-1，伪客户端处理的命令请求来源于 AOF 文件或者 Lua 脚本， 而不是网络， 所以这种客户端不需要套接字连接， 自然也不需要记录套接字描述符。</li>
<li>name：客户端名称，正常情况下客户端名称都是么有的，使用 CLIENT_SETNAME 命令可以为客户端设置一个名字</li>
<li>flags：客户端的身份和状态-具体以后再看文档吧</li>
<li>age：客户端的连接时间（s）</li>
</ul>
<h3 id="客户端命令执行"><a href="#客户端命令执行" class="headerlink" title="客户端命令执行"></a>客户端命令执行</h3><ol>
<li>客户端发出的命令会被放到redisClient的输入缓冲区 <code>querybuf</code>，querybuf的大小是动态的，但是如果超过1个G客户端就会自动断开，but redis-cli 终端默认只能输入 4095 个字符，用脚手架倒是不会超过就是了</li>
<li>分析存在缓冲区的命令，并且把命令解析之后存在 argc 和 argv里面，其中argc负责记录argv的长度，argv[0] 默认是command，后面是按顺序输入的参数（这倒就是普通的读输入逻辑</li>
</ol>
<p><img src="/../images/redis/redis_client命令.png" alt></p>
<ol start="3">
<li>根据argv[0] 的command，在命令表找到对应的redisCommand，并且把客户端的cmd指针指向对应的redisCommand，之后客户端就可以执行command命令</li>
</ol>
<p><img src="/../images/redis/redisCommandDict.png" alt></p>
<ol start="4">
<li>执行命令所得的命令回复会被保存在客户端状态的输出缓冲区里面，客户端的缓冲区有两种，固定大小缓冲区和可变大小缓冲区。简单来说就是固定大小缓冲区是自带默认的，大小默认是16kb。如果返回很大固定大小缓冲区塞不下就会用到可变大小缓冲区，可变大小缓冲区的数据结构是个链表</li>
</ol>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>这个是抄书的一个，上面讲过的客户端发送命令到收到ok的大致过程：（大家都知道就是了</p>
<blockquote>
<p>那么从客户端发送 <code>SET KEY VALUE</code> 命令到获得回复 <code>OK</code> 期间， 客户端和服务器共需要执行以下操作：</p>
<ol>
<li>客户端向服务器发送命令请求 <code>SET KEY VALUE</code> 。</li>
<li>服务器接收并处理客户端发来的命令请求 <code>SET KEY VALUE</code> ， 在数据库中进行设置操作， 并产生命令回复 <code>OK</code> 。</li>
<li>服务器将命令回复 <code>OK</code> 发送给客户端。</li>
<li>客户端接收服务器返回的命令回复 <code>OK</code> ， 并将这个回复打印给用户观看。</li>
</ol>
</blockquote>
<p>中间的细节：不想写感觉除了上一节写的东西之外也就是多讲了一些细节，比如参数校验，身份验证还有一些执行之后的后续工作，有需要再看吧</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果说上一个章节是介绍了redis在内存中保存的数据结构的话，这个章节介绍的就是redis服务器是怎么运行的，包括持久化存储逻辑，事件处理，客户端连接，处理客户端请求等（感觉这本书意外地写得挺清楚</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/12/07/redis学习笔记二：对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/12/07/redis学习笔记二：对象/" itemprop="url">
                  redis学习笔记二：对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2022-12-07 00:35:03" itemprop="dateCreated datePublished" datetime="2022-12-07T00:35:03+08:00">2022-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2023-04-11 17:46:31" itemprop="dateModified" datetime="2023-04-11T17:46:31+08:00">2023-04-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面介绍的所有的数据类型都是属于redis的底层数据结构，对象可以理解为是对底层数据结构的封装。</p>
<p>Redis 使用对象来表示数据库中的键和值，每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>表：对象的类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型常量</th>
<th style="text-align:left">对象的名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left">字符串对象（底层就是简单的字符串结构）</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left">列表对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left">哈希对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left">集合对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left">有序集合对象</td>
</tr>
</tbody>
</table>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>与此同时，对象只是一种数据类型对外的表征展示，同一个类型对象的底层数据结构可以是不一样的，这个底层结构的就是用编码<code>encoding</code> 来记录的。</p>
<p>对象的编码</p>
<table>
<thead>
<tr>
<th style="text-align:left">编码常量</th>
<th style="text-align:left">编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_INT</code></td>
<td style="text-align:left"><code>long</code> 类型的整数</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td style="text-align:left"><code>embstr</code> 编码的简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_RAW</code></td>
<td style="text-align:left">简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left">字典</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td style="text-align:left">双端链表</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">压缩列表</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_INTSET</code></td>
<td style="text-align:left">整数集合</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td style="text-align:left">跳跃表和字典</td>
</tr>
</tbody>
</table>
<hr>
<p>每种类型的对象都至少使用了两种不同的编码， 下面的表列出了每种类型的对象可以使用的编码。</p>
<p>不同类型和编码的对象</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">编码</th>
<th style="text-align:left">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_INT</code></td>
<td style="text-align:left">使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td style="text-align:left">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_RAW</code></td>
<td style="text-align:left">使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td style="text-align:left">使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left">使用字典实现的哈希对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_INTSET</code></td>
<td style="text-align:left">使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left">使用字典实现的集合对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td style="text-align:left">使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。</p>
</blockquote>
<p>就比如上面介绍压缩列表时提到的，在数据量不大的背景下（查找效率影响不大），为了优化存储空间就会被处理成压缩列表。</p>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>虽然名字叫字符串对象，但是实际上是简单赋值对象，毕竟字符串对象的编码可以是<code>int</code> 、 <code>raw</code> 或者 <code>embstr</code>。</p>
<p>浮点数也就是 <code>long double</code> 在redis底层也是存的字符串（也就是后两个），读写的时候都分别转一下。</p>
<h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p>顺便来说一下对象结构的应用，如果执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET KEY 10000</span><br></pre></td></tr></table></figure>
<p>那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code>属性里面（将 <code>void*</code> 转换成 <code>long</code> ）， 并将字符串对象的编码设置为 <code>int</code> 。当然这里的long看起来不是redis自定义的数据结构而是单纯的long类型数据结构</p>
<h4 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h4><p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 <code>39</code> 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 <code>raw</code> 。</p>
<p>看一下这下这个对象长啥样</p>
<p><img src="/../images/redis/raw编码字符串对象.png" alt></p>
<p>嘛感觉还是非常生动形象的。</p>
<h4 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h4><p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 <code>39</code> 字节， 那么字符串对象将使用 <code>embstr</code> 编码的方式来保存这个字符串值。</p>
<p>本质上来说embstr也是和前面的压缩列表一样利用连续地址空间节约内存的东西（看得出对redis来说内存有多珍贵了）</p>
<p><strong>embstr和raw的区别：</strong></p>
<p>raw分配内存的时候，分别初始化redisObj和sdshdr，然后分配两块地址空间</p>
<p>而embstr分配内存时，一口气初始化redisObj和sdshdr，初始化成一块连续的地址空间。</p>
<p>嘛至于文档里说的调用和释放少掉用一次函数这种事情并不是重点啦</p>
<blockquote>
<p>（这段是抄的但是讲的很有道理）至于为什么是39，这个讲起来就比较复杂了，我就慢点说。<br>embstr是一块连续的内存区域，由redisObject和sdshdr组成。其中redisObject占16个字节，当buf内的字符串长度是39时，sdshdr的大小为8+39+1=48，那一个字节是’\0’。加起来刚好64。是不是发现了什么？</p>
</blockquote>
<h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><ol>
<li>int -&gt; raw 当本来被设置为int的value变成字符串之后，就要进行编码转换</li>
<li>embstr -&gt; raw embstr是个只读的，所以只要对embstr进行了编辑，就会变成raw</li>
</ol>
<p>同时 embstr 是只读的，也就是说其他数据类型不能转embstr，</p>
<p>字符串应该是使用率最高的东西了（我觉得）</p>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><h4 id="ziplist-和-linkedlist"><a href="#ziplist-和-linkedlist" class="headerlink" title="ziplist 和 linkedlist"></a>ziplist 和 linkedlist</h4><p>一共有 <code>ziplist</code> 和 <code>linkedlist</code>两种</p>
<p>怎么看ziplist都是压缩列表的样子</p>
<p>linkedlist就是列表，在redis里是个双端列表的数据结构</p>
<p>不如在这里把文档里的例子都给一下，正好方便理解前面的东西（其实就是抄书）</p>
<p>Key: numbers value : 1 “three” 5</p>
<p><img src="/../images/redis/压缩列表.png" alt="压缩列表"></p>
<p><img src="/../images/redis/链表.png" alt="链表"></p>
<h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li>
<li>列表对象保存的元素数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的列表对象需要使用 <code>linkedlist</code> 编码。</p>
<p>这俩是可以在配置文件里配置的</p>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><h4 id="ziplist-和-hashtable"><a href="#ziplist-和-hashtable" class="headerlink" title="ziplist 和 hashtable"></a>ziplist 和 hashtable</h4><p>先说hashtable吧，看起来就无比正常，底层是前面的字典结构，这里书上是这么写的：</p>
<blockquote>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
</blockquote>
<p>根据前面看过的字典可以知道，dict-&gt;dictht-&gt;[]dictEntry，一个dictEntry里保存一个键值对，这个键是个指针，值可以是整数也可以是指针，书上的描述的意思应该就是每个键和值都指向了一个字符串对象的意思，嗯应该是的。</p>
<p>ziplist也就是压缩列表，数组的压缩列表很好理解嘛一个一个压起来，每个节点存个长度之类的东西就行。但是哈希有键值对的概念，所以就是先放key再放value的顺序压起来</p>
<blockquote>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
</blockquote>
<p>找肯定也是遍历找嘛这个不用怀疑，就不会和字典一样可以根据hash算法来加快找的速度</p>
<h4 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h4><p>用ziplist的条件和前面的数组一样，只要不满足条件就会从ziplist变成hashtable</p>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><h4 id="intset-和-hashtable"><a href="#intset-和-hashtable" class="headerlink" title="intset 和 hashtable"></a>intset 和 hashtable</h4><p>intset也就是前面的整数集合，这个比较好理解吧就是一堆整数集合。</p>
<p>hashtable就很神奇了，键值对里只有key是作为存储的，值则被置为null。不过仔细想想也很好理解，利用hashtable作为字段在不在set里的查找逻辑嘛，平时自己不也是这么写的</p>
<h4 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h4><p>当集合对象可以同时满足以下两个条件时， 对象使用 <code>intset</code> 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p>
<p>当然了那个512也是个配置</p>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><h4 id="ziplist-和-skiplist"><a href="#ziplist-和-skiplist" class="headerlink" title="ziplist 和 skiplist"></a>ziplist 和 skiplist</h4><p>跳表在前面看数据结构的时候就提过是用来处理有序集合的，可以利用跳表提高查找效率。</p>
<p>实际上一个skiplist包含一个跳表和一个字典</p>
<blockquote>
<p><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现， 一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<p>跳表本身没什么好说的，改存啥就存啥</p>
<p>字典就比较神奇了，key：每个节点的值，value：每个节点的score</p>
<blockquote>
<p>值得一提的是， 虽然 <code>zset</code> 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
</blockquote>
<p>确实值得一提，不然肯定有人（比如我）会问在redis这种内存大过天的地方怎么会舍得分两份内存出来照顾有序集合的</p>
<p><strong>但是为什么要用两个数据结构存有序集合？</strong></p>
<p> <code>ZRANGE</code> 这种按顺序拿值的函数，那用跳表就ok了 O(nlogn)</p>
<p><code>ZSCORE</code> 是需要根据值来获取score O(1)</p>
<p>嘛这样就可以理解了</p>
<p>压缩列表也没啥好说的，就是比较小的时候挨个排一排存起来，第一个是值第二个是score</p>
<h4 id="编码转换-4"><a href="#编码转换-4" class="headerlink" title="编码转换"></a>编码转换</h4><p>当有序集合对象可以同时满足以下两个条件时， 对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 <code>128</code> 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li>
</ol>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p>背景，redis很多操作都是针对特定对象执行的，比如set对字符串对象，hset则是对哈希对象执行，类型检查就是为了确保特定的类型执行特定的指令。</p>
<p>类型特定命令所进行的类型检查是通过 <code>redisObject</code> 结构的 <code>type</code> 属性来实现的：</p>
<ul>
<li>在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；</li>
<li>否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>其实就是不同编码支持同一个函数的情况下，这个指令就被认为支持多态，比如linkedList和zipList</p>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>redis利用引用计数来实现内存回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时， 引用计数的值会被初始化为 <code>1</code> ；</li>
<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</li>
</ul>
</blockquote>
<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>可是为什么这个对象会被多个程序引用呢，这就涉及到了对象共享逻辑。</p>
<p>比如你创建一个值为10的字符串对象，key a和key b对应的值都是10的时候，他们会指向同一个字符串对象：10。</p>
<p>说白了也就是为了节约内存。</p>
<blockquote>
<p>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 <code>0</code> 到 <code>9999</code> 的所有整数值， 当服务器需要用到值为 <code>0</code>到 <code>9999</code> 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>
</blockquote>
<p>当然这个数量也可以通过配置来修改</p>
<p>可以用 <code>OBJECT REFCOUNT</code> 来查看改对象引用量</p>
<p>比较有意思的是，目前Redis 只对包含整数值的字符串对象进行共享</p>
<p>简单来说原因就是时间复杂度-&gt;cpu耗时，整数匹配的时间复杂度为O(1) 而 字符串匹配的时间复杂度为 O(n)</p>
<p>而如果是一个哈希对象共享的话则会更加复杂，要判断键是否一致，再判断每个键下面的值是否一致，书上算出来的是O(n^2)，但是我总觉得是O(kn)</p>
<p>而且字符串被重复利用比例和整数相比要低很多</p>
<h3 id="空转时长"><a href="#空转时长" class="headerlink" title="空转时长"></a>空转时长</h3><p>用到的是redisobject里面的lru 属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>lru这个名字一出来就是老熟人了，lru记录了对象最后一次被命令程序访问的时间。用 <code>OBJECT IDLETIME</code> 命令可以打印出该对象的空转时长，也就是当前时间-lru</p>
<blockquote>
<p>键的空转时长还有另外一项作用： 如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/11/14/redis学习笔记一：数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/11/14/redis学习笔记一：数据结构/" itemprop="url">
                  redis学习笔记一：数据结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2022-11-14 23:14:05 / Modified: 23:20:07" itemprop="dateCreated datePublished" datetime="2022-11-14T23:14:05+08:00">2022-11-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一些（并不）欢乐的自学时间，用了几年了也只停留在用这个层面果然还是不行啊<br>ref：<a href="https://www.w3cschool.cn/hdclil/r489eozt.html" target="_blank" rel="noopener">https://www.w3cschool.cn/hdclil/r489eozt.html</a></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型</p>
<blockquote>
<ul>
<li>键值对的键是一个字符串对象， 对象的底层实现是一个保存着字符串 <code>&quot;msg&quot;</code> 的 SDS 。</li>
<li>键值对的值也是一个字符串对象， 对象的底层实现是一个保存着字符串 <code>&quot;hello world&quot;</code> 的 SDS 。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和C一样，字符串的buf最后是’\0’结束符，所以可以直接用printf打印出来</p>
<p>字符串：自动扩展缓冲区和内存预分配</p>
<p>缓冲区一般除非手动调用api不然不会被彻底释放，而是作为惰性空间放在free里</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>
<p>双向链表，list管理链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>整个Redis数据库的所有的键和值就组成了一个全局的字典，对数据库的增删改查操作都是构建在字典的操作之上的</p>
<p>Redis 的字典使用哈希表作为底层实现</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>table是一个数组，每个数组都指向一个dictEntry的指针，每个 <code>dictEntry</code> 结构保存着一个键值对。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>同时dictEntry有next组成一个链表，就和普通哈希逻辑一样，用链表防撞</p>
<p>就这样这个哈希表就是字典的基础结构</p>
<h3 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>type和privdata是用来适配不同的数据做不同的数据处理的：</p>
<blockquote>
<ul>
<li><code>type</code> 属性是一个指向 <code>dictType</code> 结构的指针， 每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>而 <code>privdata</code> 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
</blockquote>
<p><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</p>
<p>除了 <code>ht[1]</code> 之外， 另一个和 rehash 有关的属性就是 <code>rehashidx</code> ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ol>
<li>用hash函数计算出hash值，算法：<a href="http://code.google.com/p/smhasher/" target="_blank" rel="noopener">MurmurHash2</a></li>
<li>hash值&amp;sizemask = index</li>
</ol>
<p>解决键冲突：链表方案</p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>这也就是为什么字典的哈希表需要有两个dictht，当哈希表的大小过大或不够的时候，需要进行rehash对哈希表进行缩/扩容，其实就是重新确定sizeMask。</p>
<ol>
<li>根据ht[0]使用量确定ht[1]的sizemask大小</li>
<li>将保存在 <code>ht[0]</code> 中的所有键值对 rehash 到 <code>ht[1]</code> 上面，也就是重新计算hash值和索引值</li>
<li>释放ht[0]并把ht[1]设置为ht[0]</li>
</ol>
<p>rehash触发条件：负载因子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>
<p>当哈希表的负载因子小于 <code>0.1</code> 时， 程序自动开始对哈希表执行收缩操作。</p>
<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>其实就是当redis里的数据量太太太大的时候，不要一次性做rehash，而是多次渐近地完成</p>
<p>在字典结构中维持一个<code>rehashidx</code>，从0开始，每次对字典操作的时候就把rehashidx 对应的所有键值对都rehash掉并且对rehashidx++，直到全都rehash完了之后把<code>rehashidx</code>设置为-1</p>
<p>在这个过程中的crud都会在两个ht中执行，比如先在0找，找不到的话再去1</p>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳表之前在db里应该学过，就是针对有序链表查询的时候，不去按顺序查，而是按照一定的逻辑快速跳到接近结果的地方，从算法上看有一丝丝接近我们的二分法，把时间复杂度从n降到logn</p>
<p>在redis对外能了解的用到跳表的地方就是zset：有序集合，具体有序集合的用法自己去看吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zskiplist 结构， 该结构包含以下属性：</span><br><span class="line"></span><br><span class="line">header ：指向跳跃表的表头节点。</span><br><span class="line">tail ：指向跳跃表的表尾节点。</span><br><span class="line">level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</span><br><span class="line">length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</span><br></pre></td></tr></table></figure>
<p><img src="/../images/redis/跳表.png" alt="跳表"></p>
<h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><p>跳跃表节点的实现由 <code>redis.h/zskiplistNode</code> 结构定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line"></span><br><span class="line">    // 后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line"></span><br><span class="line">    // 分值</span><br><span class="line">    double score;</span><br><span class="line"></span><br><span class="line">    // 成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    // 层</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line"></span><br><span class="line">        // 前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line"></span><br><span class="line">        // 跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>
<h3 id="成员对象和分值"><a href="#成员对象和分值" class="headerlink" title="成员对象和分值"></a>成员对象和分值</h3><p>用来排序的依据</p>
<ul>
<li>在同一个跳跃表中,多个节点可以包含相同的分值,但每个节点的成员对象必须是唯一的，跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序；</li>
</ul>
<h3 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h3><p>好像没什么好说的就是回到前一个</p>
<h3 id="层"><a href="#层" class="headerlink" title="层"></a>层</h3><ul>
<li>每个跳跃表节点新建的时候，根据幂次定律 ( power law，越大的数出现的概率越小)随机生成一个介于 1 和 32 之间的值作为 level 数组的大小</li>
</ul>
<h3 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h3><p>层的跨度（level[i].span 属性）用于记录两个节点之间的距离：</p>
<ul>
<li>两个节点之间的跨度越大， 它们相距得就越远。</li>
<li>指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。</li>
</ul>
<p>跨度是用来计算节点位置的</p>
<h3 id="TBD"><a href="#TBD" class="headerlink" title="TBD"></a>TBD</h3><p>后面是一些自己的总结，第一是要去学一下跳表的增删改查逻辑。第二是要去查一下为什么不用平衡树而是跳表</p>
<p>平衡树：</p>
<ol>
<li><strong>主要原因</strong>：范围查找比较麻烦，跳表的范围查找相对要简单非常多</li>
<li>增删改更麻烦：引发子树调整</li>
<li>算法实现比较麻烦</li>
<li>内存可控性跳表&gt;平衡树，根据调整新建层数p大致可以估算并调整占用内存。（虽然跳表的内存占用比树要大</li>
</ol>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>如果一个集合键中，其存储的元素都是整数值时，那么这个整数键的底层实现就会是整数集合</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p>这里的contents虽然声明了int8_t，但是实际上是根据编码来的，但实际上 <code>contents</code> 数组并不保存任何 <code>int8_t</code> 类型的值 —— <code>contents</code> 数组的真正类型取决于 <code>encoding</code> 属性的值。</p>
<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>实际上这堆东西都不是在创建时就定死的，比如之前添加的是 6,8,10，突然来了一个10000000，之前使用int8存现在就要使用int16（吧？），那么这个时候整数集合就要先升级，步骤如下：</p>
<ol>
<li>根据新插入的整数大小，确定新的类型和需要分配的内存，之前是8位*3，现在是16*4</li>
<li>将之前的数字转换成int16类型，并且放在正确的位置上</li>
<li>length+1，把新增的数字放到contents的最后一位</li>
<li>encoding改为<code>INTSET_ENC_INT16</code></li>
</ol>
<h4 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h4><ul>
<li>提升整数集合的灵活性，很好理解嘛，比起C++这种一定要规定了字段类型分配内存再来插入数据的方案，这样的灵活性强很多</li>
<li>另一个是尽可能地节约内存。</li>
</ul>
<p><strong>整数类型不支持降级</strong></p>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>为了节约内存而被开发的存储结构，用处：</p>
<p>数组，哈希和有序集合（对应上面的链表，哈希表和跳表），在一定条件（比如数据量较小）的场合都会被存储为压缩列表，压缩列表的新增、删除的操作平均时间复杂度为O(N)，以哈希为例，在数据量不大的情况下这个O(N)和O(1)可以被忽略</p>
<p>表 7-1 压缩列表各个组成部分的详细说明</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">长度</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>zlbytes</code></td>
<td style="text-align:left"><code>uint32_t</code></td>
<td style="text-align:left"><code>4</code> 字节</td>
<td style="text-align:left">记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 <code>zlend</code> 的位置时使用。</td>
</tr>
<tr>
<td style="text-align:left"><code>zltail</code></td>
<td style="text-align:left"><code>uint32_t</code></td>
<td style="text-align:left"><code>4</code> 字节</td>
<td style="text-align:left">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td style="text-align:left"><code>zllen</code></td>
<td style="text-align:left"><code>uint16_t</code></td>
<td style="text-align:left"><code>2</code> 字节</td>
<td style="text-align:left">记录了压缩列表包含的节点数量： 当这个属性的值小于 <code>UINT16_MAX</code> （<code>65535</code>）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 <code>UINT16_MAX</code> 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td style="text-align:left"><code>entryX</code></td>
<td style="text-align:left">列表节点</td>
<td style="text-align:left">不定</td>
<td style="text-align:left">压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td style="text-align:left"><code>zlend</code></td>
<td style="text-align:left"><code>uint8_t</code></td>
<td style="text-align:left"><code>1</code> 字节</td>
<td style="text-align:left">特殊值 <code>0xFF</code> （十进制 <code>255</code> ），用于标记压缩列表的末端。</td>
</tr>
</tbody>
</table>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>每个压缩列表节点可以保存一个字节数组或者一个整数值</p>
<p>每个压缩列表节点都由 <code>previous_entry_length</code> 、 <code>encoding</code> 、 <code>content</code> 三个部分组成</p>
<h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的 <code>previous_entry_length</code> 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p>
<p>根据  <code>previous_entry_length</code>  ，实现压缩列表从表尾到表头的遍历。</p>
<ol>
<li>根据zltail算出指向表尾节点的指针p</li>
<li>p减去表尾节点的<code>previous_entry_length</code>，就得到指向前一个节点的起始地址的指针</li>
</ol>
<h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>节点的 <code>encoding</code> 属性记录了节点的 <code>content</code> 属性所保存数据的类型以及长度：</p>
<ul>
<li>字节数组：00,01,10开头，分别代表了不同大小的字节数组，一个节点一字节。二字节或五字节长</li>
<li>整数：11开头</li>
</ul>
<p>去除前两位的encoding可以用来计算字节数组长度或者整数类型（int16还是32还是64)</p>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>前面说过， 每个节点的 <code>previous_entry_length</code> 属性都记录了前一个节点的长度：</p>
<ul>
<li>如果前一节点的长度小于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性需要用 <code>1</code> 字节长的空间来保存这个长度值。</li>
<li>如果前一节点的长度大于等于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性需要用 <code>5</code> 字节长的空间来保存这个长度值。</li>
</ul>
<p>假设有一排小于254字节的节点的压缩列表，每个节点的 <code>previous_entry_length</code> 都是一个字节，但是如果插入一个新的大于254字节的节点作为压缩列表表头的话，最前面那个节点的 <code>previous_entry_length</code> 需要变为5个字节，就需要给压缩列表头重新分配大小。</p>
<p>这个时候会遇到一个比较特殊的场景：有一排253字节大小的节点，那么当它在表头插入新的大于254字节的节点作为压缩列表表头时-&gt;重新分配大小-&gt;节点1大小从253变为257-&gt;下一个节点重新分配 <code>previous_entry_length</code> ，最差的情况下需要把所有的节点都重新分配一次大小，也就是标题所说的连锁更新</p>
<p>but 要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：</p>
<ul>
<li>首先， 压缩列表里要恰好有多个连续的、长度介于 <code>250</code> 字节至 <code>253</code> 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</li>
<li>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</li>
</ul>
<h3 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h3><p>为什么压缩列表能节约内存：将一系列数据与其编码信息存储在一块连续的内存区域，这块内存物理上是连续的，逻辑上被分为多个组成部分，其目的是在一定可控的时间复杂读条件下尽可能的减少不必要的内存开销，从而达到节省内存的效果</p>
<p>本质就是物理内存的连续性可以节省内存以及减少内存碎片</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/golang学习笔记八：error-panic-和-recover/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/03/golang学习笔记八：error-panic-和-recover/" itemprop="url">
                  golang学习笔记八：error panic 和 recover
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-03-03 22:41:20" itemprop="dateCreated datePublished" datetime="2020-03-03T22:41:20+08:00">2020-03-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-11-14 23:22:15" itemprop="dateModified" datetime="2022-11-14T23:22:15+08:00">2022-11-14</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><p>error的基础接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也就可以套一个复杂一点的壳子，比如os.PathError</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError records an error and the operation and</span></span><br><span class="line"><span class="comment">// file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op <span class="keyword">string</span>    <span class="comment">// "open", "unlink", etc.</span></span><br><span class="line">    Path <span class="keyword">string</span>  <span class="comment">// The associated file.</span></span><br><span class="line">    Err error    <span class="comment">// Returned by the system call.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Op + <span class="string">" "</span> + e.Path + <span class="string">": "</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PathError</code>‘s <code>Error</code> generates a string like this:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /etc/passwx: no such file or directory</span><br></pre></td></tr></table></figure>
<p>这个思路就很简单，如果捕捉到有error，就可以执行一些比如回滚之类的代码来恢复或者重新执行。</p>
<h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>当然也有一些错是希望直接抛出并且停止执行的（怎么那么像throw）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A toy implementation of cube root using Newton's method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CubeRoot</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    z := x/<span class="number">3</span>   <span class="comment">// Arbitrary initial value</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1e6</span>; i++ &#123;</span><br><span class="line">        prevz := z</span><br><span class="line">        z -= (z*z*z-x) / (<span class="number">3</span>*z*z)</span><br><span class="line">        <span class="keyword">if</span> veryClose(z, prevz) &#123;</span><br><span class="line">            <span class="keyword">return</span> z</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A million iterations has not converged; something is wrong.</span></span><br><span class="line">    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"CubeRoot(%g) did not converge"</span>, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然panic也像throw一样是不被提倡的，比起抛出并且停止程序倒不如好好走完（不然也不知道会出什么问题）。</p>
<h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p><strong>当函数发生 panic 时，它会终止运行，在执行完所有的延迟函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪，最后程序终止</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullName</span><span class="params">(firstName *<span class="keyword">string</span>, lastName *<span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"deferred call in fullName"</span>)</span><br><span class="line">    <span class="keyword">if</span> firstName == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"runtime error: first name cannot be nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lastName == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"runtime error: last name cannot be nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%s %s\n"</span>, *firstName, *lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"deferred call in main"</span>)</span><br><span class="line">    firstName := <span class="string">"Elon"</span></span><br><span class="line">    fullName(&amp;firstName, <span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(<span class="string">"returned normally from main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个函数里面的defer就是<strong>延迟函数</strong>，所以遇到panic之后的输出会变成：”defer call in fullName” -&gt; “deferred call in main”-&gt;”runtime error”，利用先执行延迟函数的特征，recover出现了。在延迟函数内调用 <code>recover</code>，可以取到 <code>panic</code> 的错误信息，并且停止 panic 续发事件（Panicking Sequence），程序运行恢复正常。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverName</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r!= <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"recovered from "</span>, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullName</span><span class="params">(firstName *<span class="keyword">string</span>, lastName *<span class="keyword">string</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> recoverName()</span><br><span class="line">    <span class="keyword">if</span> firstName == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"runtime error: first name cannot be nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lastName == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"runtime error: last name cannot be nil"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%s %s\n"</span>, *firstName, *lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"deferred call in main"</span>)</span><br><span class="line">    firstName := <span class="string">"Elon"</span></span><br><span class="line">    fullName(&amp;firstName, <span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(<span class="string">"returned normally from main"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序的输出流程就会变成：”recovered from” -&gt; “returned normally from main” -&gt; “deferred call in main”</p>
<hr>
<p>到此为止effective go 这本书就算看完了，个人认为不算是一本绝佳的入门教程，但是胜在短小并且覆盖的面还蛮全面的，学到这个份儿上还不自己撸代码就有点对不起这段时间的学习了，后面的目标就是边学go的web框架边给自己定个奇奇怪怪的小目标写个实例代码吧（就聊天室吧）</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/golang学习笔记七：interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/03/golang学习笔记七：interface/" itemprop="url">
                  golang学习笔记七：interface
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-03-03 22:40:03" itemprop="dateCreated datePublished" datetime="2020-03-03T22:40:03+08:00">2020-03-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-11-14 23:22:31" itemprop="dateModified" datetime="2022-11-14T23:22:31+08:00">2022-11-14</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接口的基本介绍和使用在这里就不写了，作为 go 最重要的组成部分之一，多态等都是通过它来实现的。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h3><p>想要使用该子接口的话，必须将父接口和子接口的所有方法都实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringer <span class="keyword">interface</span>&#123; </span><br><span class="line">   <span class="keyword">string</span>()<span class="keyword">string</span></span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> tester <span class="keyword">interface</span>&#123; </span><br><span class="line">   stringer               <span class="comment">// 嵌入其他接口 </span></span><br><span class="line">   test() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插句题外话，如果structure想要像interface一样进行嵌套的话需要进行初始化。初始化方式仍旧是自己初始化and依赖注入两种。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sequence []<span class="keyword">int</span></span><br><span class="line"><span class="comment">// Method for printing - sorts the elements before printing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    s = s.Copy() <span class="comment">// Make a copy; don't overwrite argument.</span></span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    str := <span class="string">"["</span></span><br><span class="line">    <span class="keyword">for</span> i, elem := <span class="keyword">range</span> s &#123; <span class="comment">// Loop is O(N²); will fix that in next example.</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            str += <span class="string">" "</span></span><br><span class="line">        &#125;</span><br><span class="line">        str += fmt.Sprint(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str + <span class="string">"]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然我没搞懂为什么是 $O(N^2)$，但是loop浪费时间是真的，而利用类型转换就可以：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Sequence)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    s = s.Copy()</span><br><span class="line">    sort.Sort(s)</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprint([]<span class="keyword">int</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value.(type) 算是interface类型判断和转换的方法，利用switch可以进行类型判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Value provided by caller.</span></span><br><span class="line"><span class="keyword">switch</span> str := value.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line"><span class="keyword">case</span> Stringer:</span><br><span class="line">    <span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型转换则是在type里输入想转换的值，失败时在上面的情况下会抛出panic，所以也提供了第二个断言值来判断转换是否成功：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str, ok := value.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"string value is: %q\n"</span>, str)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"value is not a string\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>OO的说法摆在这里有点奇怪。。。所有的struct只要实现了interface里定义的方法，就可以被认为是这个interface的继承，这也是GO语言实现多态的方法。</p>
<blockquote>
<p>如果一个类型只是用来实现接口，并且除了该接口以外没有其它被导出的方法，那就不需要导出这个类型。只导出接口，清楚地表明了其重要的是行为，而不是实现，并且其它具有不同属性的实现可以反映原始类型的行为。这也避免了对每个公共方法实例进行重复的文档介绍。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">    Encrypt(src, dst []<span class="keyword">byte</span>)</span><br><span class="line">    Decrypt(src, dst []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stream <span class="keyword">interface</span> &#123;</span><br><span class="line">    XORKeyStream(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCTR returns a Stream that encrypts/decrypts using the given Block in</span></span><br><span class="line"><span class="comment">// counter mode. The length of iv must be the same as the Block's block size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCTR</span><span class="params">(block Block, iv []<span class="keyword">byte</span>)</span> <span class="title">Stream</span></span></span><br></pre></td></tr></table></figure>
<p>在上面的加解密的例子里，无论我们传入的是哪种加密算法都无所谓，只要实现方法是只有interface内的，就可以利用NewCTR生成对应的stream。</p>
<p>利用接口实现多态，而实现OO的继承需要使用到反射（明天再说）。</p>
<h2 id="接口详解"><a href="#接口详解" class="headerlink" title="接口详解"></a>接口详解</h2><p>可以先回忆一下OO编程中的 is-a 和 has-a。</p>
<p>is-a就是继承，简单来说就和前面的接口继承一样，有一个基类，可以派生出非常多种子类来。再简单一点解释就是基类鸟：有翅膀，有脚，会飞，吃虫子。那么我创建的所有鸟都必须有翅膀，有脚，会飞，吃虫子。</p>
<p>继承是强耦合的，如果哪天定义变了，我们认为鸟不吃虫子改吃鱼了（当然实际上鸟两个都吃忘记这个失败的比方），那么所有的子类鸟都必须吃鱼。</p>
<p>has-a就是组合，我们有翅膀，脚，心脏，血液等等类，鸟就是由这些类组合出来的，has-a是低耦合关系，哪天血液类发生了改变，血的颜色不是红的变成绿的了，对鸟这个类本身没有什么影响。</p>
<h3 id="duck-typing"><a href="#duck-typing" class="headerlink" title="duck typing"></a>duck typing</h3><p>那么我们回到 <strong>GO</strong> 语言，现在先不讲has-a，而是is-a的问题，传统OO编程的is-a是由基类产生派生类，派生类直接继承基类的所有元素，可以在基类的基础上改进or覆盖（说的就是虚函数这种面试官的最爱）。GO语言的继承和多态的概念和前面就有点微妙的不太一样，在 GO 语言中当定义了一个鸟类接口后，我们认为，所有有翅膀，有脚，会飞吃虫子的，都是鸟。</p>
<p>这个is-a就变得不再是严格的属于关系，而是通过特征来判定一个东西的归属情况，这种想法我们叫它 <strong>duck typing</strong></p>
<blockquote>
<p>鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。</p>
</blockquote>
<p>duck typing 在C++中的实现我已经不熟悉了，在GO语言中当然就是通过接口+方法的方式来实现，倒不如说GO语言本身已经没有继承这种强耦合的关系形式了。</p>
<p>一个抄来的 duck typing 的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">   Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">   Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">   Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Seeker <span class="keyword">interface</span> &#123;</span><br><span class="line">   Seek(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>) (<span class="keyword">int64</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123; <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Seek</span><span class="params">(off <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(pos <span class="keyword">int64</span>, err error)</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> file1 Reader = <span class="built_in">new</span>(File)</span><br><span class="line"><span class="keyword">var</span> file2 Writer = <span class="built_in">new</span>(File)</span><br><span class="line"><span class="keyword">var</span> file3 Closer = <span class="built_in">new</span>(File)</span><br><span class="line"><span class="keyword">var</span> file4 Seeker = <span class="built_in">new</span>(File)</span><br></pre></td></tr></table></figure>
<p>因为在File实现了4个接口，因此可以将File对象赋值给任何一个接口。</p>
<h3 id="接口值接收-Receiver"><a href="#接口值接收-Receiver" class="headerlink" title="接口值接收(Receiver)"></a>接口值接收(Receiver)</h3><blockquote>
<p>一个类型可以实现任意数量的接口，每个类型都实现了一个空接口interface{}。<br>接口是一系列接口的集合，是一种抽象数据类型，接口变量可以引用任何实现了接口的全部方法的具体数据类型的值。</p>
<p>接口变量存储了两部分信息，一个是分配给接口变量的具体值（接口实现者的值），一个是值的类型的描述器（接口实现者的类型），形式是（value, concrete type)，而不是(value, interface type)。</p>
</blockquote>
<p>下面这是一个定义了GET方法的接口，函数 f 也就是调用了接口内的 GET 方法并输出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span> &#123;</span><br><span class="line">   Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(r Retriever)</span></span> &#123;</span><br><span class="line">    s := r.Get(<span class="string">'\args'</span>)</span><br><span class="line">  	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pointer-receiver"><a href="#pointer-receiver" class="headerlink" title="pointer receiver"></a>pointer receiver</h4><p>首先来看一下指针接收者的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RealRetriever <span class="keyword">struct</span> &#123;</span><br><span class="line">   Contents <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RealRetriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> r.Contents</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    retriever := RealRetriever&#123;&#125;</span><br><span class="line">    f(&amp;retriever) <span class="comment">//pointer</span></span><br><span class="line">    f(retriever)  <span class="comment">//value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>f(&amp;retriever)</code> 执行完全没有问题，而 <code>f(retriever)</code> 会报错，简单来说就是 <code>f(retriever)</code> 是个call by value，调用的时候会对 retriever 进行复制，拷贝之后的r并不支持GET的接收者是一个指针的概念。</p>
<h4 id="value-receiver"><a href="#value-receiver" class="headerlink" title="value receiver"></a>value receiver</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MockRetriever <span class="keyword">struct</span> &#123;</span><br><span class="line">   Contents <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r MockRetriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> r.Contents</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样执行上面的代码，发现两个都是可以的，当传入的是一个引用的时候，go内部的隐式转换可以通过地址找到Get方法，而之前call by value的情况下，通过值是无法找到地址在哪儿的。</p>
<h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><blockquote>
<p>空接口类型interface{}一个方法签名也不包含，所以所有的数据类型都实现了空接口。<br>空接口类型可以用于存储任意数据类型的实例。</p>
</blockquote>
<p>空接口给了我一种指针的感觉😂，可以指向任何一个interface。</p>
<p>如果定义一个函数参数是 <code>interface{}</code> 类型，这个函数应该可以接受任何类型作为它的参数。但是对于函数内部来讲，传入的永远是一个interface类型。</p>
<p>数组的空接口则不能简单地通过等号来赋值，打个比方：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">interface</span>&#123;&#125; = t</span><br></pre></td></tr></table></figure>
<p>同理，当使用 <code>[]interface{}</code> 作为参数类型的时候，像下面这样直接传进去也是没有用的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAll</span><span class="params">(vals []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        fmt.Println(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    names := []<span class="keyword">string</span>&#123;<span class="string">"stanley"</span>, <span class="string">"david"</span>, <span class="string">"oscar"</span>&#125;</span><br><span class="line">    printAll(names)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体为什么不自动转换有个博客提到了wiki上占用存储空间的解释（我本人的怀疑就是转换代价太高）<a href="https://github.com/golang/go/wiki/InterfaceSlice" target="_blank" rel="noopener">https://github.com/golang/go/wiki/InterfaceSlice</a></p>
<p>当然可以通过手动添加地址空间来做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(t))</span><br></pre></td></tr></table></figure>
<p>判断interface的类型可以用之前类型转换里面的类型断言来做。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/24/golang学习笔记六：new-和-make/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/24/golang学习笔记六：new-和-make/" itemprop="url">
                  golang学习笔记六：new 和 make
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-02-24 21:58:10" itemprop="dateCreated datePublished" datetime="2020-02-24T21:58:10+08:00">2020-02-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-11-14 23:22:27" itemprop="dateModified" datetime="2022-11-14T23:22:27+08:00">2022-11-14</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来吧认真抄一下effective go</p>
<h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>使用new会给变量分配一个地址空间，但是并不会去初始化，而是全部定位零（zeros it）同时new返回了一个指向地址空间的指针。</p>
<p>composit literal（创建的语法？中文翻译成谜）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    f := File&#123;fd, name, <span class="literal">nil</span>, <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然就可以简化为 <code>return &amp;File{fd, name, nil, 0}</code>，而且初始化的时候可以无视顺序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;File&#123;fd: fd, name: name&#125;</span><br></pre></td></tr></table></figure>
<p>没填的两个参数会默认置空/零。</p>
<p>这样的语法可以用在很多地方，比如创建数组或者slice的时候</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="keyword">string</span>   &#123;Enone: <span class="string">"no error"</span>, Eio: <span class="string">"Eio"</span>, Einval: <span class="string">"invalid argument"</span>&#125;</span><br><span class="line">s := []<span class="keyword">string</span>      &#123;Enone: <span class="string">"no error"</span>, Eio: <span class="string">"Eio"</span>, Einval: <span class="string">"invalid argument"</span>&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;Enone: <span class="string">"no error"</span>, Eio: <span class="string">"Eio"</span>, Einval: <span class="string">"invalid argument"</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="make"><a href="#make" class="headerlink" title="make"></a>make</h4><p>哇我感觉我活的像一个汉化组。。。</p>
<ul>
<li>首先，像前面说的，make只负责创建新的slice，map和channel</li>
<li>make返回的是一个引用，所以它需要被初始化</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unnecessarily complex:</span></span><br><span class="line"><span class="keyword">var</span> p *[]<span class="keyword">int</span> = <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br><span class="line">*p = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>虽然上面那段代码被effective go认为是没必要这么复杂，但是还挺有意思的，充分地展示了new 返回指针make返回引用的特质，p就是一个初始化长度是100，容量也是100的切片。</p>
<p>当然常用写法还是下面这个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Nina">
            
              <p class="site-author-name" itemprop="name">Nina</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">33</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">37</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nina</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  
  

  
  
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  
  

  

  

  

  

  

</body>
</html>
