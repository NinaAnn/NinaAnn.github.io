<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="English">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="数组中重复数字题目：https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/ 解法：  hashmap，最容易想到的解法，但是空间复杂度O(n) 能改变nums数组的背景下将值对应index的值变为-，重复遇到时值为负，但是会改变数组值 12345678910func findDuplicate(">
<meta name="keywords" content="leetcode problems">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer memo">
<meta property="og:url" content="http://yoursite.com/2023/12/08/剑指offer-memo/index.html">
<meta property="og:site_name" content="Nina&#39;s Blog">
<meta property="og:description" content="数组中重复数字题目：https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/ 解法：  hashmap，最容易想到的解法，但是空间复杂度O(n) 能改变nums数组的背景下将值对应index的值变为-，重复遇到时值为负，但是会改变数组值 12345678910func findDuplicate(">
<meta property="og:locale" content="English">
<meta property="og:updated_time" content="2023-12-13T14:47:17.099Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer memo">
<meta name="twitter:description" content="数组中重复数字题目：https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/ 解法：  hashmap，最容易想到的解法，但是空间复杂度O(n) 能改变nums数组的背景下将值对应index的值变为-，重复遇到时值为负，但是会改变数组值 12345678910func findDuplicate(">






  <link rel="canonical" href="http://yoursite.com/2023/12/08/剑指offer-memo/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>剑指offer memo | Nina's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="English">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Nina's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Good Good Study, Day Day Up</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/12/08/剑指offer-memo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nina">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nina's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剑指offer memo
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2023-12-08 17:28:48" itemprop="dateCreated datePublished" datetime="2023-12-08T17:28:48+08:00">2023-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2023-12-13 22:47:17" itemprop="dateModified" datetime="2023-12-13T22:47:17+08:00">2023-12-13</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="数组中重复数字"><a href="#数组中重复数字" class="headerlink" title="数组中重复数字"></a>数组中重复数字</h2><p>题目：<a href="https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/" target="_blank" rel="noopener">https://leetcode.com/problems/find-the-duplicate-number/submissions/1114957310/</a></p>
<p>解法：</p>
<ol>
<li>hashmap，最容易想到的解法，但是空间复杂度O(n)</li>
<li><p>能改变nums数组的背景下将值对应index的值变为-，重复遇到时值为负，但是会改变数组值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        key := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(num)))</span><br><span class="line">        <span class="keyword">if</span> nums[key] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">        &#125;</span><br><span class="line">        nums[key] = -nums[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二分法：在n个 1-n的数字中有重复，这个问题可以理解为，在数字 1到n/2 和 n/2到n两个范围中，重复数字落下的区间所拥有的数组数字量一定比一半要更多，用这个方式可以对 1-n的数字二分最后找到答案，时间复杂度O(nlogn)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">1</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (left+right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">var</span> leftNum,rightNum <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> num &gt; mid &amp;&amp; num &lt;= right &#123;</span><br><span class="line">                rightNum++</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt;= left &amp;&amp; num &lt;= mid &#123;</span><br><span class="line">                leftNum++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> leftNum &lt;= mid - left + <span class="number">1</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>环形链表：数字和对应下标值可以组成一个链表（当然是在数字本身是1-n的背景下），比如数组 [1,3,2,2] 组成的链表就是 1-&gt;3-&gt;2-&gt;2…，最后的2就会变成一个环形链表，可以用快慢指针找环形链表的方案求解，时间复杂度O(n)，空间复杂度O(1) 完美</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fast,slow,start <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        </span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        fast = nums[nums[fast]]</span><br><span class="line">        <span class="keyword">if</span> fast == slow &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == slow &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        start = nums[start]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>题目：<a href="https://leetcode.com/problems/search-a-2d-matrix-ii/submissions/1116268925/" target="_blank" rel="noopener">https://leetcode.com/problems/search-a-2d-matrix-ii/submissions/1116268925/</a></p>
<p>没啥老朋友+1，就是从左到右从上到下递增的二维数组怎么找数字</p>
<p>从右上和左下开始的思路是一样的，以从右上开始打个比方，就是</p>
<ul>
<li>如果matrix[a][b] &gt; target，那么对所有x,y, x &gt; a &amp;&amp; y &gt; b，都比target要大，也就是整个右下角，所以可以跳过右下角的遍历</li>
<li>如果matrix[a][b] &lt; target，那么对所有x,y, x &lt; a &amp;&amp; y &lt; b，都比target要小，所以不需要关心左上角</li>
<li>从右上开始的逻辑就是，右上角已经走过了，之后只需要对左下角接着遍历就ok了</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchMatrix</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    m := <span class="built_in">len</span>(matrix)</span><br><span class="line">    x := <span class="number">0</span></span><br><span class="line">    y := <span class="built_in">len</span>(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x == m || y &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> matrix[x][y] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> matrix[x][y] &gt; target &#123;</span><br><span class="line">            y --</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p>题目：<a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>老朋友加一，同时知道前序遍历（或后序遍历）和中序遍历就能够唯一确定一颗二叉树，而前序和后序则不能</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur := &amp;TreeNode&#123;</span><br><span class="line">        Val: preorder[<span class="number">0</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> inIndex <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i,in := <span class="keyword">range</span> inorder &#123;</span><br><span class="line">        <span class="keyword">if</span> in == preorder[<span class="number">0</span>] &#123;</span><br><span class="line">            inIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.Left = buildTree(preorder[<span class="number">1</span>:inIndex+<span class="number">1</span>], inorder[<span class="number">0</span>:inIndex])</span><br><span class="line">    cur.Right = buildTree(preorder[inIndex+<span class="number">1</span>:], inorder[inIndex+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用两个栈实现堆"><a href="#用两个栈实现堆" class="headerlink" title="用两个栈实现堆"></a>用两个栈实现堆</h2><p>题目：<a href="https://leetcode.com/problems/implement-queue-using-stacks/submissions/1116341974/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-queue-using-stacks/submissions/1116341974/</a></p>
<p>没什么好讲的+1，写着玩</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    In []<span class="keyword">int</span></span><br><span class="line">    Out []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyQueue</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.In = <span class="built_in">append</span>(this.In, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.Out) == <span class="number">0</span> &#123;</span><br><span class="line">        this.Out = <span class="built_in">append</span>(this.Out, this.In...)</span><br><span class="line">        this.In = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = this.Out[<span class="number">0</span>]</span><br><span class="line">    this.Out = this.Out[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.Out) == <span class="number">0</span> &#123;</span><br><span class="line">        this.Out = <span class="built_in">append</span>(this.Out, this.In...)</span><br><span class="line">        this.In = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.Out[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.Out) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.In) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Peek();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>题目：</p>
<ul>
<li><a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">https://leetcode.com/problems/fibonacci-number/</a></li>
<li><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/description/</a></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多写两步就是爬楼梯，爬楼梯的本质方法其实就是下面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n<span class="number">-1</span>) + climbStairs(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是显而易见这是个递归，时间复杂度O(2^n)，这么简单的问题用递归太消耗时间了（虽然确实很简单），climbStairs(n-1) 和 climbStairs(n-2) 一定遇见过很多次重复计算，如果我们把爬到每层楼梯的计算结果都存下来呢？</p>
<p>下面就是用空间换时间之后的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    steps := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    steps[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    steps[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i&lt;n; i++ &#123;</span><br><span class="line">        steps[i] = steps[i<span class="number">-2</span>] + steps[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞬间就变成了时间O(n)，空间O(n)的东西了</p>
<p>最后我们发现其实每次只关心step[n-1]和step[n-2]，所以就可以简化空间：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    one := <span class="number">1</span></span><br><span class="line">    res := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line">        two := res</span><br><span class="line">        res += one</span><br><span class="line">        one = two</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>最后总结一下，dp本质上就是用空间换时间，主要的流程分为以下三步：</p>
<ol>
<li>写出递归公式 f(n) = f(n-k)+f(n-w) （简单打个比方）</li>
<li>用空间换时间方法写出dp解法</li>
<li>优化空间</li>
</ol>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>题目：<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/</a></p>
<p>解法就是显而易见的二分法，写二分法的时候我为了看起来舒服所以个人习惯喜欢写递归，这次把迭代递归两种都写一下：<br>递归：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">  &#125;   </span><br><span class="line">  mid := (<span class="number">0</span> + <span class="built_in">len</span>(nums) - <span class="number">1</span> ) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">if</span> nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>] &lt; nums[mid] &#123;</span><br><span class="line">      <span class="keyword">return</span> findMin(nums[mid+<span class="number">1</span>:])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> findMin(nums[<span class="number">0</span>:mid+<span class="number">1</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMin</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    right := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        &#125;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] &lt; nums[mid] &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h2><p>题目：<a href="https://leetcode.com/problems/word-search/solutions/2498848/simple-backtracking-with-go/" target="_blank" rel="noopener">https://leetcode.com/problems/word-search/solutions/2498848/simple-backtracking-with-go/</a></p>
<p>典型回溯法求解，一开始天真地写了个外部函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i,row := <span class="keyword">range</span> board &#123;</span><br><span class="line">        <span class="keyword">for</span> j,_ := <span class="keyword">range</span> row &#123;</span><br><span class="line">            res := find(board,word,<span class="number">0</span>,i,j)</span><br><span class="line">            <span class="keyword">if</span> res == <span class="literal">true</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>, wordIndex,x,y <span class="keyword">int</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">        m := <span class="built_in">len</span>(board)</span><br><span class="line">    n := <span class="built_in">len</span>(board[<span class="number">0</span>]) </span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> board[x][y] != []<span class="keyword">byte</span>(word)[wordIndex] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> wordIndex == <span class="built_in">len</span>(word) - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    tmp := board[x][y]</span><br><span class="line">    board[x][y] = <span class="keyword">byte</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    wordIndex++</span><br><span class="line">    res := <span class="literal">false</span></span><br><span class="line">        res = find(board,word,wordIndex,x,y + <span class="number">1</span>) || find(board,word,wordIndex,x,y - <span class="number">1</span>) || find(board,word,wordIndex,x<span class="number">-1</span>,y) || find(board,word,wordIndex,x+<span class="number">1</span>,y)</span><br><span class="line">        </span><br><span class="line">    board[x][y] = tmp</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后发现go可以搞闭包：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(board)</span><br><span class="line">    n := <span class="built_in">len</span>(board[<span class="number">0</span>]) </span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(x,y,wordIndex <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(x,y,wordIndex <span class="keyword">int</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> board[x][y] != []<span class="keyword">byte</span>(word)[wordIndex] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> wordIndex == <span class="built_in">len</span>(word) - <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        tmp := board[x][y]</span><br><span class="line">        board[x][y] = <span class="keyword">byte</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        wordIndex++</span><br><span class="line">        res := <span class="literal">false</span></span><br><span class="line">        res = backtrack(x,y + <span class="number">1</span>, wordIndex) || backtrack(x,y - <span class="number">1</span>, wordIndex) || backtrack(x<span class="number">-1</span>,y, wordIndex) || backtrack(x+<span class="number">1</span>,y,wordIndex)</span><br><span class="line">            </span><br><span class="line">        board[x][y] = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i,row := <span class="keyword">range</span> board &#123;</span><br><span class="line">        <span class="keyword">for</span> j,_ := <span class="keyword">range</span> row &#123;</span><br><span class="line">            <span class="keyword">if</span> backtrack(i,j,<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h2><p>题目： <a href="https://leetcode.com/problems/number-of-1-bits/solutions/4340903/o-log-n-c-python-java-explained/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-1-bits/solutions/4340903/o-log-n-c-python-java-explained/</a></p>
<p>解法：<br>简单遍历取余，时间复杂度 O(logn)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> time <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num %<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            time++</span><br><span class="line">        &#125;</span><br><span class="line">        num /= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以写成位运算的形式（从计算效率来说位运算肯定比除法好很多）（为什么？）：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(num <span class="keyword">uint32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> time <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        time+= <span class="keyword">int</span>(num%<span class="number">2</span>)</span><br><span class="line">        num &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><p>题目：<a href="https://leetcode.com/problems/powx-n/" target="_blank" rel="noopener">https://leetcode.com/problems/powx-n/</a></p>
<p>解法：</p>
<ol>
<li>顺着乘起来，时间复杂度是O(n)</li>
<li>假设二进制 n = 1001， $a^n$ = $a^8*a$，可以把时间复杂度降低到 $log_2n$</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> powVal <span class="keyword">float64</span></span><br><span class="line">    powVal = <span class="number">1</span></span><br><span class="line">    newN := <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(n)))</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> newN==<span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> newN &amp; <span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">            powVal *= x</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x</span><br><span class="line">        newN = newN &gt;&gt; <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> powVal</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/powVal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在O-1-时间内删除链表节点"><a href="#在O-1-时间内删除链表节点" class="headerlink" title="在O(1)时间内删除链表节点"></a>在O(1)时间内删除链表节点</h2><p>题目：<a href="https://leetcode.com/problems/delete-node-in-a-linked-list/submissions/1117061591/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-node-in-a-linked-list/submissions/1117061591/</a></p>
<p>简单来说考验的就是对链表的熟悉程度</p>
<ol>
<li>一开始想到的方案是把链表整个往左移，所以写了个循环 </li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(node *ListNode)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"node:%v"</span>,node.Next)</span><br><span class="line">        <span class="keyword">if</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            node.Val = node.Next.Val</span><br><span class="line">            <span class="keyword">if</span> node.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">                node.Next = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">break</span>        </span><br><span class="line">            &#125;</span><br><span class="line">            node = node.Next</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>后来发现自己就是个弱智，直接把下一个节点跳过不就行了？题目还强调了那么多次保证不会给末端节点，不审题唉<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(node *ListNode)</span></span> &#123;</span><br><span class="line">    node.Val = node.Next.Val</span><br><span class="line">    node.Next = node.Next.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="删除链表中重复的节点"><a href="#删除链表中重复的节点" class="headerlink" title="删除链表中重复的节点"></a>删除链表中重复的节点</h2><p>题目：<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/</a></p>
<p>自己写的时候多绕了一层，判断是否重复，然后再挨个判断<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    newHead := &amp;ListNode&#123;</span><br><span class="line">        Val: <span class="number">-101</span>,</span><br><span class="line">        Next : head,</span><br><span class="line">    &#125;</span><br><span class="line">    cur := newHead</span><br><span class="line">    before := <span class="number">-101</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cur.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cur.Next.Val == before &#123;</span><br><span class="line">            cur.Next = cur.Next.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> cur.Next.Next != <span class="literal">nil</span> &amp;&amp; cur.Next.Val == cur.Next.Next.Val &#123;</span><br><span class="line">            before = cur.Next.Val</span><br><span class="line">            cur.Next = cur.Next.Next.Next</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以把每个节点内加个判断重复的循环就行了，性能差不多但是代码可读性和理解会更简单一点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    newHead := &amp;ListNode&#123;</span><br><span class="line">        Val: <span class="number">-101</span>,</span><br><span class="line">        Next : head,</span><br><span class="line">    &#125;</span><br><span class="line">    cur := head</span><br><span class="line">    before := newHead</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> count <span class="keyword">int</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.Next == <span class="literal">nil</span> ||cur.Next.Val != cur.Val &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.Next</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            before.Next = cur</span><br><span class="line">            before = cur</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    before.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>题目：<a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/</a></p>
<p>经典dp题，做了好一阵子</p>
<p>首先写出dp公式，一开始的时候写出来是这样的：</p>
<ul>
<li>假设 i:字符串index,j:正则index</li>
<li>当p[j] 不等于 ‘*’ 时，dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i] = p[j] || p[j] = ‘.’)</li>
<li>当p[j] 等于 ‘*’ 时，dp[i][j] = (s[i] = p[j-1] || p[j-1] = ‘.’) &amp;&amp; (dp[i-1][j-1] || dp[i-1][j])</li>
</ul>
<p>美滋滋写完发现报错了，忽略了一种场景：input= “aab”, regx = “c*a*b”，也就是”c*“不是”c+”，没有字符也是ok的</p>
<p>所以在这个的基础上针对输入加了第0位，也就是空字符串的正则表达匹配，最后的公式等于：</p>
<ul>
<li>假设 i:字符串index,j:正则index</li>
<li>当p[j] 不等于 ‘*’ 时，dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i] = p[j] || p[j] = ‘.’)</li>
<li>当p[j] 等于 ‘*’ 时，dp[i][j] = (s[i] = p[j-1] || p[j-1] = ‘.’) &amp;&amp; (dp[i-1][j-1] || dp[i-1][j]) || <strong>dp[i][j-2]</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dps [][]<span class="keyword">bool</span></span><br><span class="line">    m := <span class="built_in">len</span>(s)</span><br><span class="line">    n := <span class="built_in">len</span>(p)</span><br><span class="line">    dps = <span class="built_in">make</span>([][]<span class="keyword">bool</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> d:= <span class="number">0</span>; d&lt; m+<span class="number">1</span>; d++ &#123;</span><br><span class="line">        dps[d] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dps[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span>  i:=<span class="number">0</span>; i&lt;=m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>;j&lt;=n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> p[j<span class="number">-1</span>] != <span class="string">'*'</span> &#123;</span><br><span class="line">                dps[i][j] = i &gt; <span class="number">0</span> &amp;&amp; dps[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>]  == <span class="string">'.'</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dps[i][j] = (i &gt; <span class="number">0</span> &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>]  == <span class="string">'.'</span>) &amp;&amp; (dps[i<span class="number">-1</span>][j] || dps[i<span class="number">-1</span>][j<span class="number">-1</span>])) || dps[i][j<span class="number">-2</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dps[m][n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合法数值字符串"><a href="#合法数值字符串" class="headerlink" title="合法数值字符串"></a>合法数值字符串</h2><p>题目：<a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-number/</a></p>
<p>解法：</p>
<ol>
<li><p>本能用了有限状态自动机来做：</p>
<ul>
<li>状态0:字符串开始和结束</li>
<li>状态1:符号</li>
<li>状态2:数字</li>
<li>状态3:e和E</li>
<li>状态4:前面没有出现过数字的.</li>
<li>状态5:前面出现过数字的.<br>然后构建了一个状态转移矩阵，不过因为其实需要处理的特殊场景比较多（比如E和.只能出现一次），所以还是出现了不少if else判断，其实也可以把这些if else都转成其他状态，但是懒了这样也挺好<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isNumber</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    trans :=[<span class="number">6</span>][<span class="number">6</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> hasE,hasPoint,hasVal <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">var</span> preStatus <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _,val := <span class="keyword">range</span> s&#123;</span><br><span class="line">        <span class="keyword">var</span> status = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> val == <span class="string">'-'</span>|| val == <span class="string">'+'</span>&#123;</span><br><span class="line">            status = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> val &gt;= <span class="string">'0'</span> &amp;&amp; val &lt;= <span class="string">'9'</span> &#123;</span><br><span class="line">            status = <span class="number">2</span></span><br><span class="line">            hasVal = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> val == <span class="string">'.'</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> hasPoint &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> hasVal &#123;</span><br><span class="line">                status = <span class="number">5</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status = <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            hasPoint = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> val == <span class="string">'E'</span> || val == <span class="string">'e'</span> &#123;</span><br><span class="line">            status = <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> hasE &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            hasE = <span class="literal">true</span></span><br><span class="line">            hasPoint = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> trans[preStatus][status] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        preStatus = status</span><br><span class="line">    &#125;</span><br><span class="line">    status := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> trans[preStatus][status] == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>正则，当然是个很不错的解法 <code>const regex Solution::pattern(&quot;[+-]?(?:\\d+\\.?\\d*|\\.\\d+)(?:[Ee][+-]?\\d+)?&quot;)</code> 但是y1s1对正则真的不是特别熟练。。。</p>
</li>
</ol>
<h2 id="按奇偶排序数组"><a href="#按奇偶排序数组" class="headerlink" title="按奇偶排序数组"></a>按奇偶排序数组</h2><p>题目：<a href="https://leetcode.com/problems/sort-array-by-parity/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-array-by-parity/</a></p>
<p>非常典型的双指针题，遍历都是一遍过没有问题<br>解法：</p>
<ol>
<li><p>分配一个新的数组存，空间复杂度会变成O(n)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArrayByParity</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="keyword">int</span>, end+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _,num:= <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            res[start] = num</span><br><span class="line">            start++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[end] = num</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原地交换，空间复杂度O(1)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortArrayByParity</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[start]%<span class="number">2</span> ==  &amp;&amp; start &lt; end&#123;</span><br><span class="line">                start++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[end]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; end &gt; start&#123;</span><br><span class="line">                end--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp := nums[start]</span><br><span class="line">            nums[start] = nums[end]</span><br><span class="line">            nums[end] = tmp</span><br><span class="line">            start++</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="链表中倒数第n个节点"><a href="#链表中倒数第n个节点" class="headerlink" title="链表中倒数第n个节点"></a>链表中倒数第n个节点</h2><p>题目：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p>
<p>没啥，前后指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    newHead := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    start := newHead</span><br><span class="line">    end := newHead</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        start = start.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> start.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            start = start.Next</span><br><span class="line">            end = end.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end.Next = end.Next.Next</span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表环入口"><a href="#链表环入口" class="headerlink" title="链表环入口"></a>链表环入口</h2><p>题目：<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/</a><br>解法见第一题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    fast := head</span><br><span class="line">    slow := head</span><br><span class="line">    <span class="keyword">var</span> step <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || slow == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> || slow == <span class="literal">nil</span> || fast.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> step == <span class="number">0</span> || fast != slow &#123;</span><br><span class="line">            fast = fast.Next.Next</span><br><span class="line">            slow = slow.Next</span><br><span class="line">            step++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 肯定有环，找入口就行</span></span><br><span class="line">    start := head</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start != slow &#123;</span><br><span class="line">            start = start.Next</span><br><span class="line">            slow = slow.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>题目：<a href="https://leetcode.com/problems/reverse-linked-list/solutions/3211778/using-2-methods-iterative-recursive-beats-97-91/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/solutions/3211778/using-2-methods-iterative-recursive-beats-97-91/</a></p>
<p>老朋友了+1，没什么好说的，写了两种解法：</p>
<ol>
<li><p>循环迭代，时间复杂度O(n)，空间复杂度 O(1)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    newHead := &amp;ListNode&#123;</span><br><span class="line">        Next:<span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">            old := newHead.Next</span><br><span class="line">            newHead.Next = head</span><br><span class="line">            head = head.Next</span><br><span class="line">            newHead.Next.Next = old</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归：时间复杂度O(n)，空间复杂度 O(n)（函数调用空间）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    newHead := reverseList(head.Next)</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> newHead</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h2><p>题目：<a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/</a></p>
<p>不优雅但好理解，好理解最重要～<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(list1 *ListNode, list2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    newHead := &amp;ListNode&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    head := newHead</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> list1 == <span class="literal">nil</span> &amp;&amp; list2 == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> list1.Val &lt; list2.Val &#123;</span><br><span class="line">            head.Next = list1</span><br><span class="line">            list1 = list1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.Next = list2</span><br><span class="line">            list2 = list2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left *ListNode </span><br><span class="line">    <span class="keyword">if</span> list1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        left = list1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = list2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left != <span class="literal">nil</span> &#123;</span><br><span class="line">            head.Next = left</span><br><span class="line">            head = head.Next</span><br><span class="line">            left = left.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="判断是否子树"><a href="#判断是否子树" class="headerlink" title="判断是否子树"></a>判断是否子树</h2><p>题目：<a href="https://leetcode.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/subtree-of-another-tree/</a></p>
<p>题解：</p>
<p>我自己写的时候思路是把判断是子树往下走的逻辑和找子树的逻辑混在一块写了，用isSub来判断是在判断子树部分是否一致还是在找子树，这样不是很好看懂还有一堆判断逻辑<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(root *TreeNode, subRoot *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> findSub(root,subRoot,<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSub</span> <span class="params">(root *TreeNode, subRoot *TreeNode, isSub <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &amp;&amp; subRoot == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || subRoot == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> root.Val == subRoot.Val &#123;</span><br><span class="line">        res = findSub(root.Left,subRoot.Left, <span class="literal">true</span>) &amp;&amp; findSub(root.Right,subRoot.Right, <span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> isSub &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !isSub &#123;</span><br><span class="line">        res = res || findSub(root.Left,subRoot, <span class="literal">false</span>) || findSub(root.Right,subRoot, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把判断是否一致的逻辑单独拆出来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubtree</span><span class="params">(root *TreeNode, subRoot *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || subRoot == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == subRoot</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isIdentical(root,subRoot) || isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isIdentical</span> <span class="params">(root *TreeNode, subRoot *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> || subRoot == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == subRoot</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">if</span> root.Val == subRoot.Val &#123;</span><br><span class="line">        res = isIdentical(root.Left,subRoot.Left) &amp;&amp; isIdentical(root.Right,subRoot.Right)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>题目：<a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/description/</a></p>
<p>解法：</p>
<ol>
<li><p>dfs递归，说实话递归没啥好写的，就是个普通的递归就结束了（所以说人类爱写递归不是没有原因的，太好写也太好懂了虽然占地方）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> right,left *TreeNode</span><br><span class="line">    right = invertTree(root.Left)</span><br><span class="line">    left = invertTree(root.Right)</span><br><span class="line">    root.Left = left</span><br><span class="line">    root.Right = right</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bfs，用队列来遍历二叉树，以后经常会这么做，习惯就好</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> stack []*TreeNode</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        l := <span class="built_in">len</span>(stack)</span><br><span class="line">        <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        head := stack[l - <span class="number">1</span>]</span><br><span class="line">        stack = stack[:l<span class="number">-1</span>]</span><br><span class="line">        tmp := head.Right</span><br><span class="line">        head.Right = head.Left</span><br><span class="line">        head.Left = tmp</span><br><span class="line">        <span class="keyword">if</span> head.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, head.Right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> head.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, head.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><p>题目：<a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a></p>
<p>当然肯定有用堆来做的解法，一样一样的，偷懒不想写了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> symmetric(root.Left, root.Right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">symmetric</span><span class="params">(left *TreeNode, right *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left == <span class="literal">nil</span> || right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left == right</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left.Val == right.Val &#123;</span><br><span class="line">        <span class="keyword">return</span> symmetric(left.Left, right.Right) &amp;&amp;  symmetric(left.Right, right.Left)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><p>题目：<a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/spiral-matrix/</a></p>
<p>题解：设置上下左右边界，按照边界进行遍历就行，时间复杂度O(mn)，空间复杂度O(1)，因为只需要记录四个边界</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left,right,up,down <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">    right = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    down = <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left &gt; right || up &gt; down &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i:= left; i &lt;= right; i++ &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, matrix[up][i])</span><br><span class="line">        &#125;</span><br><span class="line">        up++</span><br><span class="line">        <span class="keyword">for</span> i:= up; i&lt;= down; i++ &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, matrix[i][right])</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        right--</span><br><span class="line">        <span class="keyword">if</span> up &lt;= down &#123;</span><br><span class="line">            <span class="keyword">for</span> i:= right; i &gt;= left; i-- &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, matrix[down][i])</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            down--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> left &lt;= right &#123;</span><br><span class="line">            <span class="keyword">for</span> i:= down; i&gt;= up; i-- &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, matrix[i][left])</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="min-stack"><a href="#min-stack" class="headerlink" title="min stack"></a>min stack</h2><p>题目：<a href="https://leetcode.com/problems/min-stack/submissions/1117973116/" target="_blank" rel="noopener">https://leetcode.com/problems/min-stack/submissions/1117973116/</a></p>
<p>解法：</p>
<ol>
<li><p>辅助栈。时间复杂度O(1)，空间复杂度O(n)，简单来说就是搞个辅助栈minStack，利用栈先进后出的特性保存当前栈的最小值（一开始把栈和堆搞反了怎么也做不出来）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack []<span class="keyword">int</span></span><br><span class="line">    minStack []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    this.stack = <span class="built_in">append</span>(this.stack,val)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.minStack) &gt; <span class="number">0</span> &amp;&amp;  this.minStack[<span class="built_in">len</span>(this.minStack) - <span class="number">1</span>] &lt; val &#123;</span><br><span class="line">        this.minStack = <span class="built_in">append</span>(this.minStack, this.minStack[<span class="built_in">len</span>(this.minStack) - <span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        this.minStack = <span class="built_in">append</span>(this.minStack, val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    this.minStack = this.minStack[<span class="number">0</span>:<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">GetMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.minStack[<span class="built_in">len</span>(this.minStack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>空间复杂度为O(1)的辅助栈：受到了一点题解的启发，用和最小值的差值而不是当前值来保存，不过说实话这么难以阅读的逻辑不要也罢</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack []<span class="keyword">int</span></span><br><span class="line">    min <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;</span><br><span class="line">        min:<span class="number">-1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.stack) == <span class="number">0</span> &#123;</span><br><span class="line">        this.min = val</span><br><span class="line">    &#125;</span><br><span class="line">    diff := val - this.min</span><br><span class="line">    this.stack = <span class="built_in">append</span>(this.stack,diff)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> diff &lt; <span class="number">0</span>&#123;</span><br><span class="line">        this.min = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    val := this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> val &lt; <span class="number">0</span> &#123;</span><br><span class="line">        this.min -= val</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    val := this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span> val &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> this.min</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val + this.min</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span> <span class="title">GetMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="判断栈压入弹出序列合法"><a href="#判断栈压入弹出序列合法" class="headerlink" title="判断栈压入弹出序列合法"></a>判断栈压入弹出序列合法</h2><p>题目：<a href="https://leetcode.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">https://leetcode.com/problems/validate-stack-sequences/</a></p>
<p>题解：其实就是模拟栈来处理</p>
<ol>
<li>空间复杂度O(1)但是修改原数组，因为不是很清楚go的删除节点是不是要O(n)一下，所以非常不建议</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateStackSequences</span><span class="params">(pushed []<span class="keyword">int</span>, popped []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i,j <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(pushed) &#123;</span><br><span class="line">            <span class="keyword">return</span> i == <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">-1</span> || pushed[i] != popped[j] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp := pushed[i+<span class="number">1</span>:]</span><br><span class="line">            pushed = <span class="built_in">append</span>(pushed[:i], tmp...)</span><br><span class="line">            j++</span><br><span class="line">            i--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用辅助数组来模拟栈的操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateStackSequences</span><span class="params">(pushed []<span class="keyword">int</span>, popped []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> help []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _,val := <span class="keyword">range</span> pushed &#123;</span><br><span class="line">        help = <span class="built_in">append</span>(help, val)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(help) &gt; <span class="number">0</span> &amp;&amp; popped[i] == help[<span class="built_in">len</span>(help) - <span class="number">1</span>] &#123;</span><br><span class="line">                help = help[:<span class="built_in">len</span>(help) - <span class="number">1</span>]</span><br><span class="line">                i++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(help) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="分行从上到下打印二叉树"><a href="#分行从上到下打印二叉树" class="headerlink" title="分行从上到下打印二叉树"></a>分行从上到下打印二叉树</h2><p>题目：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/submissions/1118009830/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/submissions/1118009830/</a></p>
<p>题解：用堆就结束了，时间和空间复杂度都是O(n)，除了go不提供堆这种数据结构之外没有什么难点</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> heap []*TreeNode</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    heap = <span class="built_in">append</span>(heap, root)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp := heap</span><br><span class="line">        heap = []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">var</span> resTmp []<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> _,node := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">            resTmp = <span class="built_in">append</span>(resTmp, node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                heap = <span class="built_in">append</span>(heap, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                heap = <span class="built_in">append</span>(heap, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, resTmp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分行之字打印二叉树"><a href="#分行之字打印二叉树" class="headerlink" title="分行之字打印二叉树"></a>分行之字打印二叉树</h2><p>题目：<a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a></p>
<p>和上题差不多就是个欢乐堆bfs</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> heap []*TreeNode</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    heap = <span class="built_in">append</span>(heap, root)</span><br><span class="line">    inOrder := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp := heap</span><br><span class="line">        heap = []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">var</span> tmpRes []<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">for</span> i:= <span class="built_in">len</span>(tmp) <span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- &#123;</span><br><span class="line">            node := tmp[i]</span><br><span class="line">            tmpRes = <span class="built_in">append</span>(tmpRes, node.Val)</span><br><span class="line">            <span class="keyword">if</span> inOrder &#123;</span><br><span class="line">                <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    heap = <span class="built_in">append</span>(heap, node.Left)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    heap = <span class="built_in">append</span>(heap, node.Right)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                    heap = <span class="built_in">append</span>(heap, node.Right)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                    heap = <span class="built_in">append</span>(heap, node.Left)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder = !inOrder</span><br><span class="line">            res = <span class="built_in">append</span>(res, tmpRes)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断二叉搜索树后续遍历合法"><a href="#判断二叉搜索树后续遍历合法" class="headerlink" title="判断二叉搜索树后续遍历合法"></a>判断二叉搜索树后续遍历合法</h2><p>（leetcode要钱所以去了牛客）题目：<a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p>二叉搜索树：根节点内所有左子树值\&lt;root，所有右子树值> root</p>
<p>解法递归本身没什么问题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifySquenceOfBST</span><span class="params">( sequence []<span class="keyword">int</span> )</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sequence) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">var</span> checkRight <span class="function"><span class="keyword">func</span><span class="params">(left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line">    checkRight = <span class="function"><span class="keyword">func</span><span class="params">(left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        rootVal := sequence[right]</span><br><span class="line">        <span class="keyword">var</span> i = right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> ; i&gt;= left; i-- &#123;</span><br><span class="line">            <span class="keyword">if</span> sequence[i] &lt; rootVal &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j:=left;j&lt;=i;j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> sequence[j] &gt;= rootVal &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkRight(left, i) &amp;&amp; checkRight(i+<span class="number">1</span>,right<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> checkRight(<span class="number">0</span>,<span class="built_in">len</span>(sequence) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><p>题目：<a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/</a></p>
<p>题解：</p>
<ol>
<li><p>简单dfs</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> checkVal <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>, before []<span class="keyword">int</span>)</span></span> </span><br><span class="line">    checkVal = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, nowSum <span class="keyword">int</span>, before []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        nowSum += root.Val </span><br><span class="line">        before = <span class="built_in">append</span>(before, root.Val)</span><br><span class="line">        <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nowSum == targetSum &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, before...))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        checkVal(root.Left, nowSum, before)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        checkVal(root.Right, nowSum, before)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    checkVal(root,<span class="number">0</span>,[]<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用回溯法优化路径存储，只要有一个path就行不需要传参</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> path []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> checkVal <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span></span> </span><br><span class="line">    checkVal = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, nowSum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        nowSum += root.Val </span><br><span class="line">        path = <span class="built_in">append</span>(path, root.Val)</span><br><span class="line">        <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nowSum == targetSum &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;&#125;, path...))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                checkVal(root.Left, nowSum)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                checkVal(root.Right, nowSum)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    checkVal(root,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h2><p>题目：<a href="https://leetcode.com/problems/copy-list-with-random-pointer/submissions/1118858301/" target="_blank" rel="noopener">https://leetcode.com/problems/copy-list-with-random-pointer/submissions/1118858301/</a></p>
<p>解法：</p>
<ol>
<li><p>用hash保存已经创建的链表（面试答不出来就用这个方法），空间复杂度是O(n)，时间复杂度O(n)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    nodeMap := <span class="keyword">map</span>[*Node]*Node&#123;&#125;</span><br><span class="line">    cur := &amp;Node&#123;</span><br><span class="line">        Val: head.Val,</span><br><span class="line">    &#125;</span><br><span class="line">    newNode := &amp;Node &#123;</span><br><span class="line">        Next: cur,</span><br><span class="line">    &#125;</span><br><span class="line">    nodeMap[head] = cur</span><br><span class="line">    nodeMap[<span class="literal">nil</span>] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> next,ok := nodeMap[head.Next]; ok &#123;</span><br><span class="line">            cur.Next = next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next :=&amp;Node&#123;</span><br><span class="line">                Val: head.Next.Val,</span><br><span class="line">            &#125;</span><br><span class="line">            nodeMap[head.Next] = next</span><br><span class="line">            cur.Next = next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rand,ok := nodeMap[head.Random]; ok &#123;</span><br><span class="line">            cur.Random = rand</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rad :=&amp;Node&#123;</span><br><span class="line">                Val: head.Random.Val,</span><br><span class="line">            &#125;</span><br><span class="line">            nodeMap[head.Random] = rad</span><br><span class="line">            cur.Random = rad</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur.Next</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原地复制链表，从1-&gt;2-&gt;3 变成 1-&gt;1<em>-&gt;2-&gt;2</em>-&gt;3-&gt;3*，再去进行random赋值和链表拆分，所以一共有三个循环</p>
<ol>
<li>原地复制当前节点，组成复制后链表</li>
<li>复制后节点的random指向</li>
<li>拆开两个链表</li>
</ol>
</li>
</ol>
<p>最后的时间复杂度:O(n)，空间复杂度O(1)<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    newNode := &amp;Node&#123;</span><br><span class="line">        Next:head,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        next := &amp;Node&#123;</span><br><span class="line">            Val:head.Val,</span><br><span class="line">            Next:head.Next,</span><br><span class="line">        &#125;</span><br><span class="line">        head.Next = next</span><br><span class="line">        head = next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head = newNode.Next</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> head.Random != <span class="literal">nil</span> &#123;</span><br><span class="line">            head.Next.Random = head.Random.Next</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    head = newNode.Next  </span><br><span class="line">    newHead := head.Next</span><br><span class="line">    newH := newHead</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        </span><br><span class="line">        head.Next = newHead.Next</span><br><span class="line">        head = head.Next</span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">nil</span>  &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        newHead.Next = head.Next</span><br><span class="line">        newHead = newHead.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="双向链表转二叉搜索树"><a href="#双向链表转二叉搜索树" class="headerlink" title="双向链表转二叉搜索树"></a>双向链表转二叉搜索树</h2><p>题目：<a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=2&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</a></p>
<p>题解：</p>
<ol>
<li>用数组存中序遍历的结果，然后再重新组装（空间复杂度O(n)）（不想写了</li>
<li><p>原地处理数组，我写的方法好像比较复杂一点，不过性能一样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convert</span><span class="params">( pRootOfTree *TreeNode )</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> pRootOfTree == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    left := pRootOfTree</span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        left = convLeft(pRootOfTree.Left, pRootOfTree)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        convRight(pRootOfTree.Right, pRootOfTree)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convLeft</span><span class="params">( pRootOfTree *TreeNode , before *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    left := pRootOfTree</span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        left = convLeft(pRootOfTree.Left,pRootOfTree)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        right := convRight(pRootOfTree.Right,pRootOfTree)</span><br><span class="line">        before.Left = right</span><br><span class="line">        right.Right = before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        before.Left = pRootOfTree</span><br><span class="line">        pRootOfTree.Right = before</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convRight</span><span class="params">( pRootOfTree *TreeNode, before *TreeNode )</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    right := pRootOfTree</span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        left := convLeft(pRootOfTree.Left,pRootOfTree)</span><br><span class="line">        before.Right = left</span><br><span class="line">        left.Left = before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        before.Right = pRootOfTree</span><br><span class="line">        pRootOfTree.Left = before</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pRootOfTree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">        right = convRight(pRootOfTree.Right,pRootOfTree)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以先找到最左的开始节点，再中序遍历就行了，符合中序遍历的核心思想</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Convert</span><span class="params">( pRootOfTree *TreeNode )</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> pRootOfTree == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left = pRootOfTree</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> left.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = left.Left</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> preNode *TreeNode</span><br><span class="line">    <span class="keyword">var</span> inOrder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    inOrder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.Left)</span><br><span class="line">        root.Left = preNode</span><br><span class="line">        <span class="keyword">if</span> preNode != <span class="literal">nil</span> &#123;</span><br><span class="line">            preNode.Right = root</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = root</span><br><span class="line">        inOrder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(pRootOfTree)</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/leetcode-problems/" rel="tag"># leetcode problems</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/12/08/刷题碎碎念一：环形链表快慢指针之为什么/" rel="next" title="刷题碎碎念一：环形链表快慢指针之为什么">
                <i class="fa fa-chevron-left"></i> 刷题碎碎念一：环形链表快慢指针之为什么
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/12/13/找工作TBD/" rel="prev" title="找工作TBD">
                找工作TBD <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Nina">
            
              <p class="site-author-name" itemprop="name">Nina</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">37</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组中重复数字"><span class="nav-number">1.</span> <span class="nav-text">数组中重复数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二维数组中的查找"><span class="nav-number">2.</span> <span class="nav-text">二维数组中的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重建二叉树"><span class="nav-number">3.</span> <span class="nav-text">重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用两个栈实现堆"><span class="nav-number">4.</span> <span class="nav-text">用两个栈实现堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#斐波那契数列"><span class="nav-number">5.</span> <span class="nav-text">斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#旋转数组的最小数字"><span class="nav-number">6.</span> <span class="nav-text">旋转数组的最小数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵中的路径"><span class="nav-number">7.</span> <span class="nav-text">矩阵中的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制中1的个数"><span class="nav-number">8.</span> <span class="nav-text">二进制中1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值的整数次方"><span class="nav-number">9.</span> <span class="nav-text">数值的整数次方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在O-1-时间内删除链表节点"><span class="nav-number">10.</span> <span class="nav-text">在O(1)时间内删除链表节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除链表中重复的节点"><span class="nav-number">11.</span> <span class="nav-text">删除链表中重复的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则表达式"><span class="nav-number">12.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合法数值字符串"><span class="nav-number">13.</span> <span class="nav-text">合法数值字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#按奇偶排序数组"><span class="nav-number">14.</span> <span class="nav-text">按奇偶排序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表中倒数第n个节点"><span class="nav-number">15.</span> <span class="nav-text">链表中倒数第n个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表环入口"><span class="nav-number">16.</span> <span class="nav-text">链表环入口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反转链表"><span class="nav-number">17.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并两个排序链表"><span class="nav-number">18.</span> <span class="nav-text">合并两个排序链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断是否子树"><span class="nav-number">19.</span> <span class="nav-text">判断是否子树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#翻转二叉树"><span class="nav-number">20.</span> <span class="nav-text">翻转二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对称的二叉树"><span class="nav-number">21.</span> <span class="nav-text">对称的二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺时针打印矩阵"><span class="nav-number">22.</span> <span class="nav-text">顺时针打印矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#min-stack"><span class="nav-number">23.</span> <span class="nav-text">min stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断栈压入弹出序列合法"><span class="nav-number">24.</span> <span class="nav-text">判断栈压入弹出序列合法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分行从上到下打印二叉树"><span class="nav-number">25.</span> <span class="nav-text">分行从上到下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分行之字打印二叉树"><span class="nav-number">26.</span> <span class="nav-text">分行之字打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断二叉搜索树后续遍历合法"><span class="nav-number">27.</span> <span class="nav-text">判断二叉搜索树后续遍历合法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树中和为某一值的路径"><span class="nav-number">28.</span> <span class="nav-text">二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机链表的复制"><span class="nav-number">29.</span> <span class="nav-text">随机链表的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向链表转二叉搜索树"><span class="nav-number">30.</span> <span class="nav-text">双向链表转二叉搜索树</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nina</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  



	





  





  










  





  

  

  

  
  

  
  

  


  
  

  

  

  

  

  

</body>
</html>
